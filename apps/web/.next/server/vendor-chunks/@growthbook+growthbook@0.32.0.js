"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@growthbook+growthbook@0.32.0";
exports.ids = ["vendor-chunks/@growthbook+growthbook@0.32.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/GrowthBook.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/GrowthBook.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GrowthBook: () => (/* binding */ GrowthBook)\n/* harmony export */ });\n/* harmony import */ var dom_mutator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom-mutator */ \"(ssr)/../../node_modules/.pnpm/dom-mutator@0.6.0/node_modules/dom-mutator/dist/dom-mutator.esm.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/util.js\");\n/* harmony import */ var _mongrule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mongrule */ \"(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/mongrule.js\");\n/* harmony import */ var _feature_repository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./feature-repository */ \"(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/feature-repository.js\");\n\n\n\n\nconst isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst SDK_VERSION = (0,_util__WEBPACK_IMPORTED_MODULE_1__.loadSDKVersion)();\nclass GrowthBook {\n  // context is technically private, but some tools depend on it so we can't mangle the name\n  // _ctx below is a clone of this property that we use internally\n\n  // Properties and methods that start with \"_\" are mangled by Terser (saves ~150 bytes)\n\n  // eslint-disable-next-line\n\n  constructor(context) {\n    context = context || {};\n    // These properties are all initialized in the constructor instead of above\n    // This saves ~80 bytes in the final output\n    this.version = SDK_VERSION;\n    this._ctx = this.context = context;\n    this._renderer = null;\n    this._trackedExperiments = new Set();\n    this._trackedFeatures = {};\n    this.debug = false;\n    this._subscriptions = new Set();\n    this._rtQueue = [];\n    this._rtTimer = 0;\n    this.ready = false;\n    this._assigned = new Map();\n    this._forcedFeatureValues = new Map();\n    this._attributeOverrides = {};\n    this._activeAutoExperiments = new Map();\n    this._triggeredExpKeys = new Set();\n    this._loadFeaturesCalled = false;\n    if (context.remoteEval) {\n      if (context.decryptionKey) {\n        throw new Error(\"Encryption is not available for remoteEval\");\n      }\n      if (!context.clientKey) {\n        throw new Error(\"Missing clientKey\");\n      }\n      let isGbHost = false;\n      try {\n        isGbHost = !!new URL(context.apiHost || \"\").hostname.match(/growthbook\\.io$/i);\n      } catch (e) {\n        // ignore invalid URLs\n      }\n      if (isGbHost) {\n        throw new Error(\"Cannot use remoteEval on GrowthBook Cloud\");\n      }\n    } else {\n      if (context.cacheKeyAttributes) {\n        throw new Error(\"cacheKeyAttributes are only used for remoteEval\");\n      }\n    }\n    if (context.features) {\n      this.ready = true;\n    }\n    if (isBrowser && context.enableDevMode) {\n      window._growthbook = this;\n      document.dispatchEvent(new Event(\"gbloaded\"));\n    }\n    if (context.experiments) {\n      this.ready = true;\n      this._updateAllAutoExperiments();\n    }\n    if (context.clientKey && !context.remoteEval) {\n      this._refresh({}, true, false);\n    }\n  }\n  async loadFeatures(options) {\n    if (options && options.autoRefresh) {\n      // interpret deprecated autoRefresh option as subscribeToChanges\n      this._ctx.subscribeToChanges = true;\n    }\n    this._loadFeaturesCalled = true;\n    await this._refresh(options, true, true);\n    if (this._canSubscribe()) {\n      (0,_feature_repository__WEBPACK_IMPORTED_MODULE_2__.subscribe)(this);\n    }\n  }\n  async refreshFeatures(options) {\n    await this._refresh(options, false, true);\n  }\n  getApiInfo() {\n    return [this.getApiHosts().apiHost, this.getClientKey()];\n  }\n  getApiHosts() {\n    const defaultHost = this._ctx.apiHost || \"https://cdn.growthbook.io\";\n    return {\n      apiHost: defaultHost.replace(/\\/*$/, \"\"),\n      streamingHost: (this._ctx.streamingHost || defaultHost).replace(/\\/*$/, \"\"),\n      apiRequestHeaders: this._ctx.apiHostRequestHeaders,\n      streamingHostRequestHeaders: this._ctx.streamingHostRequestHeaders\n    };\n  }\n  getClientKey() {\n    return this._ctx.clientKey || \"\";\n  }\n  isRemoteEval() {\n    return this._ctx.remoteEval || false;\n  }\n  getCacheKeyAttributes() {\n    return this._ctx.cacheKeyAttributes;\n  }\n  async _refresh(options, allowStale, updateInstance) {\n    options = options || {};\n    if (!this._ctx.clientKey) {\n      throw new Error(\"Missing clientKey\");\n    }\n    await (0,_feature_repository__WEBPACK_IMPORTED_MODULE_2__.refreshFeatures)(this, options.timeout, options.skipCache || this._ctx.enableDevMode, allowStale, updateInstance, this._ctx.backgroundSync !== false);\n  }\n  _render() {\n    if (this._renderer) {\n      this._renderer();\n    }\n  }\n  setFeatures(features) {\n    this._ctx.features = features;\n    this.ready = true;\n    this._render();\n  }\n  async setEncryptedFeatures(encryptedString, decryptionKey, subtle) {\n    const featuresJSON = await (0,_util__WEBPACK_IMPORTED_MODULE_1__.decrypt)(encryptedString, decryptionKey || this._ctx.decryptionKey, subtle);\n    this.setFeatures(JSON.parse(featuresJSON));\n  }\n  setExperiments(experiments) {\n    this._ctx.experiments = experiments;\n    this.ready = true;\n    this._updateAllAutoExperiments();\n  }\n  async setEncryptedExperiments(encryptedString, decryptionKey, subtle) {\n    const experimentsJSON = await (0,_util__WEBPACK_IMPORTED_MODULE_1__.decrypt)(encryptedString, decryptionKey || this._ctx.decryptionKey, subtle);\n    this.setExperiments(JSON.parse(experimentsJSON));\n  }\n  async decryptPayload(data, decryptionKey, subtle) {\n    if (data.encryptedFeatures) {\n      data.features = JSON.parse(await (0,_util__WEBPACK_IMPORTED_MODULE_1__.decrypt)(data.encryptedFeatures, decryptionKey || this._ctx.decryptionKey, subtle));\n      delete data.encryptedFeatures;\n    }\n    if (data.encryptedExperiments) {\n      data.experiments = JSON.parse(await (0,_util__WEBPACK_IMPORTED_MODULE_1__.decrypt)(data.encryptedExperiments, decryptionKey || this._ctx.decryptionKey, subtle));\n      delete data.encryptedExperiments;\n    }\n    return data;\n  }\n  async setAttributes(attributes) {\n    this._ctx.attributes = attributes;\n    if (this._ctx.stickyBucketService) {\n      await this.refreshStickyBuckets();\n    }\n    if (this._ctx.remoteEval) {\n      await this._refreshForRemoteEval();\n      return;\n    }\n    this._render();\n    this._updateAllAutoExperiments();\n  }\n  async setAttributeOverrides(overrides) {\n    this._attributeOverrides = overrides;\n    if (this._ctx.stickyBucketService) {\n      await this.refreshStickyBuckets();\n    }\n    if (this._ctx.remoteEval) {\n      await this._refreshForRemoteEval();\n      return;\n    }\n    this._render();\n    this._updateAllAutoExperiments();\n  }\n  async setForcedVariations(vars) {\n    this._ctx.forcedVariations = vars || {};\n    if (this._ctx.remoteEval) {\n      await this._refreshForRemoteEval();\n      return;\n    }\n    this._render();\n    this._updateAllAutoExperiments();\n  }\n\n  // eslint-disable-next-line\n  setForcedFeatures(map) {\n    this._forcedFeatureValues = map;\n    this._render();\n  }\n  async setURL(url) {\n    this._ctx.url = url;\n    if (this._ctx.remoteEval) {\n      await this._refreshForRemoteEval();\n      this._updateAllAutoExperiments(true);\n      return;\n    }\n    this._updateAllAutoExperiments(true);\n  }\n  getAttributes() {\n    return {\n      ...this._ctx.attributes,\n      ...this._attributeOverrides\n    };\n  }\n  getForcedVariations() {\n    return this._ctx.forcedVariations || {};\n  }\n  getForcedFeatures() {\n    // eslint-disable-next-line\n    return this._forcedFeatureValues || new Map();\n  }\n  getStickyBucketAssignmentDocs() {\n    return this._ctx.stickyBucketAssignmentDocs || {};\n  }\n  getUrl() {\n    return this._ctx.url || \"\";\n  }\n  getFeatures() {\n    return this._ctx.features || {};\n  }\n  getExperiments() {\n    return this._ctx.experiments || [];\n  }\n  subscribe(cb) {\n    this._subscriptions.add(cb);\n    return () => {\n      this._subscriptions.delete(cb);\n    };\n  }\n  _canSubscribe() {\n    return this._ctx.backgroundSync !== false && this._ctx.subscribeToChanges;\n  }\n  async _refreshForRemoteEval() {\n    if (!this._ctx.remoteEval) return;\n    if (!this._loadFeaturesCalled) return;\n    await this._refresh({}, false, true).catch(() => {\n      // Ignore errors\n    });\n  }\n  getAllResults() {\n    return new Map(this._assigned);\n  }\n  destroy() {\n    // Release references to save memory\n    this._subscriptions.clear();\n    this._assigned.clear();\n    this._trackedExperiments.clear();\n    this._trackedFeatures = {};\n    this._rtQueue = [];\n    if (this._rtTimer) {\n      clearTimeout(this._rtTimer);\n    }\n    (0,_feature_repository__WEBPACK_IMPORTED_MODULE_2__.unsubscribe)(this);\n    if (isBrowser && window._growthbook === this) {\n      delete window._growthbook;\n    }\n\n    // Undo any active auto experiments\n    this._activeAutoExperiments.forEach(exp => {\n      exp.undo();\n    });\n    this._activeAutoExperiments.clear();\n    this._triggeredExpKeys.clear();\n  }\n  setRenderer(renderer) {\n    this._renderer = renderer;\n  }\n  forceVariation(key, variation) {\n    this._ctx.forcedVariations = this._ctx.forcedVariations || {};\n    this._ctx.forcedVariations[key] = variation;\n    if (this._ctx.remoteEval) {\n      this._refreshForRemoteEval();\n      return;\n    }\n    this._updateAllAutoExperiments();\n    this._render();\n  }\n  run(experiment) {\n    const result = this._run(experiment, null);\n    this._fireSubscriptions(experiment, result);\n    return result;\n  }\n  triggerExperiment(key) {\n    this._triggeredExpKeys.add(key);\n    if (!this._ctx.experiments) return null;\n    const experiments = this._ctx.experiments.filter(exp => exp.key === key);\n    return experiments.map(exp => {\n      if (!exp.manual) return null;\n      return this._runAutoExperiment(exp);\n    }).filter(res => res !== null);\n  }\n  _runAutoExperiment(experiment, forceRerun) {\n    const existing = this._activeAutoExperiments.get(experiment);\n\n    // If this is a manual experiment and it's not already running, skip\n    if (experiment.manual && !this._triggeredExpKeys.has(experiment.key) && !existing) return null;\n\n    // Run the experiment\n    const result = this.run(experiment);\n\n    // A hash to quickly tell if the assigned value changed\n    const valueHash = JSON.stringify(result.value);\n\n    // If the changes are already active, no need to re-apply them\n    if (!forceRerun && result.inExperiment && existing && existing.valueHash === valueHash) {\n      return result;\n    }\n\n    // Undo any existing changes\n    if (existing) this._undoActiveAutoExperiment(experiment);\n\n    // Apply new changes\n    if (result.inExperiment) {\n      const undo = this._applyDOMChanges(result.value);\n      if (undo) {\n        this._activeAutoExperiments.set(experiment, {\n          undo,\n          valueHash\n        });\n      }\n    }\n    return result;\n  }\n  _undoActiveAutoExperiment(exp) {\n    const data = this._activeAutoExperiments.get(exp);\n    if (data) {\n      data.undo();\n      this._activeAutoExperiments.delete(exp);\n    }\n  }\n  _updateAllAutoExperiments(forceRerun) {\n    const experiments = this._ctx.experiments || [];\n\n    // Stop any experiments that are no longer defined\n    const keys = new Set(experiments);\n    this._activeAutoExperiments.forEach((v, k) => {\n      if (!keys.has(k)) {\n        v.undo();\n        this._activeAutoExperiments.delete(k);\n      }\n    });\n\n    // Re-run all new/updated experiments\n    experiments.forEach(exp => {\n      this._runAutoExperiment(exp, forceRerun);\n    });\n  }\n  _fireSubscriptions(experiment, result) {\n    const key = experiment.key;\n\n    // If assigned variation has changed, fire subscriptions\n    const prev = this._assigned.get(key);\n    // TODO: what if the experiment definition has changed?\n    if (!prev || prev.result.inExperiment !== result.inExperiment || prev.result.variationId !== result.variationId) {\n      this._assigned.set(key, {\n        experiment,\n        result\n      });\n      this._subscriptions.forEach(cb => {\n        try {\n          cb(experiment, result);\n        } catch (e) {\n          console.error(e);\n        }\n      });\n    }\n  }\n  _trackFeatureUsage(key, res) {\n    // Don't track feature usage that was forced via an override\n    if (res.source === \"override\") return;\n\n    // Only track a feature once, unless the assigned value changed\n    const stringifiedValue = JSON.stringify(res.value);\n    if (this._trackedFeatures[key] === stringifiedValue) return;\n    this._trackedFeatures[key] = stringifiedValue;\n\n    // Fire user-supplied callback\n    if (this._ctx.onFeatureUsage) {\n      try {\n        this._ctx.onFeatureUsage(key, res);\n      } catch (e) {\n        // Ignore feature usage callback errors\n      }\n    }\n\n    // In browser environments, queue up feature usage to be tracked in batches\n    if (!isBrowser || !window.fetch) return;\n    this._rtQueue.push({\n      key,\n      on: res.on\n    });\n    if (!this._rtTimer) {\n      this._rtTimer = window.setTimeout(() => {\n        // Reset the queue\n        this._rtTimer = 0;\n        const q = [...this._rtQueue];\n        this._rtQueue = [];\n\n        // Skip logging if a real-time usage key is not configured\n        if (!this._ctx.realtimeKey) return;\n        window.fetch(\"https://rt.growthbook.io/?key=\".concat(this._ctx.realtimeKey, \"&events=\").concat(encodeURIComponent(JSON.stringify(q))), {\n          cache: \"no-cache\",\n          mode: \"no-cors\"\n        }).catch(() => {\n          // TODO: retry in case of network errors?\n        });\n      }, this._ctx.realtimeInterval || 2000);\n    }\n  }\n  _getFeatureResult(key, value, source, ruleId, experiment, result) {\n    const ret = {\n      value,\n      on: !!value,\n      off: !value,\n      source,\n      ruleId: ruleId || \"\"\n    };\n    if (experiment) ret.experiment = experiment;\n    if (result) ret.experimentResult = result;\n\n    // Track the usage of this feature in real-time\n    this._trackFeatureUsage(key, ret);\n    return ret;\n  }\n  isOn(key) {\n    return this.evalFeature(key).on;\n  }\n  isOff(key) {\n    return this.evalFeature(key).off;\n  }\n  getFeatureValue(key, defaultValue) {\n    const value = this.evalFeature(key).value;\n    return value === null ? defaultValue : value;\n  }\n\n  /**\n   * @deprecated Use {@link evalFeature}\n   * @param id\n   */\n  // eslint-disable-next-line\n  feature(id) {\n    return this.evalFeature(id);\n  }\n  evalFeature(id) {\n    // Global override\n    if (this._forcedFeatureValues.has(id)) {\n       true && this.log(\"Global override\", {\n        id,\n        value: this._forcedFeatureValues.get(id)\n      });\n      return this._getFeatureResult(id, this._forcedFeatureValues.get(id), \"override\");\n    }\n\n    // Unknown feature id\n    if (!this._ctx.features || !this._ctx.features[id]) {\n       true && this.log(\"Unknown feature\", {\n        id\n      });\n      return this._getFeatureResult(id, null, \"unknownFeature\");\n    }\n\n    // Get the feature\n    const feature = this._ctx.features[id];\n\n    // Loop through the rules\n    if (feature.rules) {\n      for (const rule of feature.rules) {\n        // If there are filters for who is included (e.g. namespaces)\n        if (rule.filters && this._isFilteredOut(rule.filters)) {\n           true && this.log(\"Skip rule because of filters\", {\n            id,\n            rule\n          });\n          continue;\n        }\n\n        // Feature value is being forced\n        if (\"force\" in rule) {\n          // If it's a conditional rule, skip if the condition doesn't pass\n          if (rule.condition && !this._conditionPasses(rule.condition)) {\n             true && this.log(\"Skip rule because of condition ff\", {\n              id,\n              rule\n            });\n            continue;\n          }\n\n          // If this is a percentage rollout, skip if not included\n          if (!this._isIncludedInRollout(rule.seed || id, rule.hashAttribute, this._ctx.stickyBucketService && !rule.disableStickyBucketing ? rule.fallbackAttribute : undefined, rule.range, rule.coverage, rule.hashVersion)) {\n             true && this.log(\"Skip rule because user not included in rollout\", {\n              id,\n              rule\n            });\n            continue;\n          }\n           true && this.log(\"Force value from rule\", {\n            id,\n            rule\n          });\n\n          // If this was a remotely evaluated experiment, fire the tracking callbacks\n          if (rule.tracks) {\n            rule.tracks.forEach(t => {\n              this._track(t.experiment, t.result);\n            });\n          }\n          return this._getFeatureResult(id, rule.force, \"force\", rule.id);\n        }\n        if (!rule.variations) {\n           true && this.log(\"Skip invalid rule\", {\n            id,\n            rule\n          });\n          continue;\n        }\n\n        // For experiment rules, run an experiment\n        const exp = {\n          variations: rule.variations,\n          key: rule.key || id\n        };\n        if (\"coverage\" in rule) exp.coverage = rule.coverage;\n        if (rule.weights) exp.weights = rule.weights;\n        if (rule.hashAttribute) exp.hashAttribute = rule.hashAttribute;\n        if (rule.fallbackAttribute) exp.fallbackAttribute = rule.fallbackAttribute;\n        if (rule.disableStickyBucketing) exp.disableStickyBucketing = rule.disableStickyBucketing;\n        if (rule.bucketVersion !== undefined) exp.bucketVersion = rule.bucketVersion;\n        if (rule.minBucketVersion !== undefined) exp.minBucketVersion = rule.minBucketVersion;\n        if (rule.namespace) exp.namespace = rule.namespace;\n        if (rule.meta) exp.meta = rule.meta;\n        if (rule.ranges) exp.ranges = rule.ranges;\n        if (rule.name) exp.name = rule.name;\n        if (rule.phase) exp.phase = rule.phase;\n        if (rule.seed) exp.seed = rule.seed;\n        if (rule.hashVersion) exp.hashVersion = rule.hashVersion;\n        if (rule.filters) exp.filters = rule.filters;\n        if (rule.condition) exp.condition = rule.condition;\n\n        // Only return a value if the user is part of the experiment\n        const res = this._run(exp, id);\n        this._fireSubscriptions(exp, res);\n        if (res.inExperiment && !res.passthrough) {\n          return this._getFeatureResult(id, res.value, \"experiment\", rule.id, exp, res);\n        }\n      }\n    }\n     true && this.log(\"Use default value\", {\n      id,\n      value: feature.defaultValue\n    });\n\n    // Fall back to using the default value\n    return this._getFeatureResult(id, feature.defaultValue === undefined ? null : feature.defaultValue, \"defaultValue\");\n  }\n  _isIncludedInRollout(seed, hashAttribute, fallbackAttribute, range, coverage, hashVersion) {\n    if (!range && coverage === undefined) return true;\n    const {\n      hashValue\n    } = this._getHashAttribute(hashAttribute, fallbackAttribute);\n    if (!hashValue) {\n      return false;\n    }\n    const n = (0,_util__WEBPACK_IMPORTED_MODULE_1__.hash)(seed, hashValue, hashVersion || 1);\n    if (n === null) return false;\n    return range ? (0,_util__WEBPACK_IMPORTED_MODULE_1__.inRange)(n, range) : coverage !== undefined ? n <= coverage : true;\n  }\n  _conditionPasses(condition) {\n    return (0,_mongrule__WEBPACK_IMPORTED_MODULE_3__.evalCondition)(this.getAttributes(), condition);\n  }\n  _isFilteredOut(filters) {\n    return filters.some(filter => {\n      const {\n        hashValue\n      } = this._getHashAttribute(filter.attribute);\n      if (!hashValue) return true;\n      const n = (0,_util__WEBPACK_IMPORTED_MODULE_1__.hash)(filter.seed, hashValue, filter.hashVersion || 2);\n      if (n === null) return true;\n      return !filter.ranges.some(r => (0,_util__WEBPACK_IMPORTED_MODULE_1__.inRange)(n, r));\n    });\n  }\n  _run(experiment, featureId) {\n    const key = experiment.key;\n    const numVariations = experiment.variations.length;\n\n    // 1. If experiment has less than 2 variations, return immediately\n    if (numVariations < 2) {\n       true && this.log(\"Invalid experiment\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 2. If the context is disabled, return immediately\n    if (this._ctx.enabled === false) {\n       true && this.log(\"Context disabled\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 2.5. Merge in experiment overrides from the context\n    experiment = this._mergeOverrides(experiment);\n\n    // 3. If a variation is forced from a querystring, return the forced variation\n    const qsOverride = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getQueryStringOverride)(key, this._getContextUrl(), numVariations);\n    if (qsOverride !== null) {\n       true && this.log(\"Force via querystring\", {\n        id: key,\n        variation: qsOverride\n      });\n      return this._getResult(experiment, qsOverride, false, featureId);\n    }\n\n    // 4. If a variation is forced in the context, return the forced variation\n    if (this._ctx.forcedVariations && key in this._ctx.forcedVariations) {\n      const variation = this._ctx.forcedVariations[key];\n       true && this.log(\"Force via dev tools\", {\n        id: key,\n        variation\n      });\n      return this._getResult(experiment, variation, false, featureId);\n    }\n\n    // 5. Exclude if a draft experiment or not active\n    if (experiment.status === \"draft\" || experiment.active === false) {\n       true && this.log(\"Skip because inactive\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 6. Get the hash attribute and return if empty\n    const {\n      hashAttribute,\n      hashValue\n    } = this._getHashAttribute(experiment.hashAttribute, this._ctx.stickyBucketService && !experiment.disableStickyBucketing ? experiment.fallbackAttribute : undefined);\n    if (!hashValue) {\n       true && this.log(\"Skip because missing hashAttribute\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n    let assigned = -1;\n    let foundStickyBucket = false;\n    let stickyBucketVersionIsBlocked = false;\n    if (this._ctx.stickyBucketService && !experiment.disableStickyBucketing) {\n      const {\n        variation,\n        versionIsBlocked\n      } = this._getStickyBucketVariation(experiment.key, experiment.bucketVersion, experiment.minBucketVersion, experiment.meta);\n      foundStickyBucket = variation >= 0;\n      assigned = variation;\n      stickyBucketVersionIsBlocked = !!versionIsBlocked;\n    }\n\n    // Some checks are not needed if we already have a sticky bucket\n    if (!foundStickyBucket) {\n      // 7. Exclude if user is filtered out (used to be called \"namespace\")\n      if (experiment.filters) {\n        if (this._isFilteredOut(experiment.filters)) {\n           true && this.log(\"Skip because of filters\", {\n            id: key\n          });\n          return this._getResult(experiment, -1, false, featureId);\n        }\n      } else if (experiment.namespace && !(0,_util__WEBPACK_IMPORTED_MODULE_1__.inNamespace)(hashValue, experiment.namespace)) {\n         true && this.log(\"Skip because of namespace\", {\n          id: key\n        });\n        return this._getResult(experiment, -1, false, featureId);\n      }\n\n      // 7.5. Exclude if experiment.include returns false or throws\n      if (experiment.include && !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isIncluded)(experiment.include)) {\n         true && this.log(\"Skip because of include function\", {\n          id: key\n        });\n        return this._getResult(experiment, -1, false, featureId);\n      }\n\n      // 8. Exclude if condition is false\n      if (experiment.condition && !this._conditionPasses(experiment.condition)) {\n         true && this.log(\"Skip because of condition exp\", {\n          id: key\n        });\n        return this._getResult(experiment, -1, false, featureId);\n      }\n\n      // 8.1. Exclude if user is not in a required group\n      if (experiment.groups && !this._hasGroupOverlap(experiment.groups)) {\n         true && this.log(\"Skip because of groups\", {\n          id: key\n        });\n        return this._getResult(experiment, -1, false, featureId);\n      }\n    }\n\n    // 8.2. Old style URL targeting\n    if (experiment.url && !this._urlIsValid(experiment.url)) {\n       true && this.log(\"Skip because of url\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8.3. New, more powerful URL targeting\n    if (experiment.urlPatterns && !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isURLTargeted)(this._getContextUrl(), experiment.urlPatterns)) {\n       true && this.log(\"Skip because of url targeting\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 9. Get the variation from the sticky bucket or get bucket ranges and choose variation\n    const n = (0,_util__WEBPACK_IMPORTED_MODULE_1__.hash)(experiment.seed || key, hashValue, experiment.hashVersion || 1);\n    if (n === null) {\n       true && this.log(\"Skip because of invalid hash version\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n    if (!foundStickyBucket) {\n      const ranges = experiment.ranges || (0,_util__WEBPACK_IMPORTED_MODULE_1__.getBucketRanges)(numVariations, experiment.coverage === undefined ? 1 : experiment.coverage, experiment.weights);\n      assigned = (0,_util__WEBPACK_IMPORTED_MODULE_1__.chooseVariation)(n, ranges);\n    }\n\n    // 9.5 Unenroll if any prior sticky buckets are blocked by version\n    if (stickyBucketVersionIsBlocked) {\n       true && this.log(\"Skip because sticky bucket version is blocked\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId, undefined, true);\n    }\n\n    // 10. Return if not in experiment\n    if (assigned < 0) {\n       true && this.log(\"Skip because of coverage\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 11. Experiment has a forced variation\n    if (\"force\" in experiment) {\n       true && this.log(\"Force variation\", {\n        id: key,\n        variation: experiment.force\n      });\n      return this._getResult(experiment, experiment.force === undefined ? -1 : experiment.force, false, featureId);\n    }\n\n    // 12. Exclude if in QA mode\n    if (this._ctx.qaMode) {\n       true && this.log(\"Skip because QA mode\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 12.5. Exclude if experiment is stopped\n    if (experiment.status === \"stopped\") {\n       true && this.log(\"Skip because stopped\", {\n        id: key\n      });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 13. Build the result object\n    const result = this._getResult(experiment, assigned, true, featureId, n, foundStickyBucket);\n\n    // 13.5. Persist sticky bucket\n    if (this._ctx.stickyBucketService && !experiment.disableStickyBucketing) {\n      const {\n        changed,\n        key: attrKey,\n        doc\n      } = this._generateStickyBucketAssignmentDoc(hashAttribute, (0,_util__WEBPACK_IMPORTED_MODULE_1__.toString)(hashValue), {\n        [this._getStickyBucketExperimentKey(experiment.key, experiment.bucketVersion)]: result.key\n      });\n      if (changed) {\n        // update local docs\n        this._ctx.stickyBucketAssignmentDocs = this._ctx.stickyBucketAssignmentDocs || {};\n        this._ctx.stickyBucketAssignmentDocs[attrKey] = doc;\n        // save doc\n        this._ctx.stickyBucketService.saveAssignments(doc);\n      }\n    }\n\n    // 14. Fire the tracking callback\n    this._track(experiment, result);\n\n    // 15. Return the result\n     true && this.log(\"In experiment\", {\n      id: key,\n      variation: result.variationId\n    });\n    return result;\n  }\n  log(msg, ctx) {\n    if (!this.debug) return;\n    if (this._ctx.log) this._ctx.log(msg, ctx);else console.log(msg, ctx);\n  }\n  _track(experiment, result) {\n    if (!this._ctx.trackingCallback) return;\n    const key = experiment.key;\n\n    // Make sure a tracking callback is only fired once per unique experiment\n    const k = result.hashAttribute + result.hashValue + key + result.variationId;\n    if (this._trackedExperiments.has(k)) return;\n    this._trackedExperiments.add(k);\n    try {\n      this._ctx.trackingCallback(experiment, result);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  _mergeOverrides(experiment) {\n    const key = experiment.key;\n    const o = this._ctx.overrides;\n    if (o && o[key]) {\n      experiment = Object.assign({}, experiment, o[key]);\n      if (typeof experiment.url === \"string\") {\n        experiment.url = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getUrlRegExp)(\n        // eslint-disable-next-line\n        experiment.url);\n      }\n    }\n    return experiment;\n  }\n  _getHashAttribute(attr, fallback) {\n    let hashAttribute = attr || \"id\";\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let hashValue = \"\";\n    if (this._attributeOverrides[hashAttribute]) {\n      hashValue = this._attributeOverrides[hashAttribute];\n    } else if (this._ctx.attributes) {\n      hashValue = this._ctx.attributes[hashAttribute] || \"\";\n    } else if (this._ctx.user) {\n      hashValue = this._ctx.user[hashAttribute] || \"\";\n    }\n\n    // if no match, try fallback\n    if (!hashValue && fallback) {\n      if (this._attributeOverrides[fallback]) {\n        hashValue = this._attributeOverrides[fallback];\n      } else if (this._ctx.attributes) {\n        hashValue = this._ctx.attributes[fallback] || \"\";\n      } else if (this._ctx.user) {\n        hashValue = this._ctx.user[fallback] || \"\";\n      }\n      if (hashValue) {\n        hashAttribute = fallback;\n      }\n    }\n    return {\n      hashAttribute,\n      hashValue\n    };\n  }\n  _getResult(experiment, variationIndex, hashUsed, featureId, bucket, stickyBucketUsed) {\n    let inExperiment = true;\n    // If assigned variation is not valid, use the baseline and mark the user as not in the experiment\n    if (variationIndex < 0 || variationIndex >= experiment.variations.length) {\n      variationIndex = 0;\n      inExperiment = false;\n    }\n    const {\n      hashAttribute,\n      hashValue\n    } = this._getHashAttribute(experiment.hashAttribute, this._ctx.stickyBucketService && !experiment.disableStickyBucketing ? experiment.fallbackAttribute : undefined);\n    const meta = experiment.meta ? experiment.meta[variationIndex] : {};\n    const res = {\n      key: meta.key || \"\" + variationIndex,\n      featureId,\n      inExperiment,\n      hashUsed,\n      variationId: variationIndex,\n      value: experiment.variations[variationIndex],\n      hashAttribute,\n      hashValue,\n      stickyBucketUsed: !!stickyBucketUsed\n    };\n    if (meta.name) res.name = meta.name;\n    if (bucket !== undefined) res.bucket = bucket;\n    if (meta.passthrough) res.passthrough = meta.passthrough;\n    return res;\n  }\n  _getContextUrl() {\n    return this._ctx.url || (isBrowser ? window.location.href : \"\");\n  }\n  _urlIsValid(urlRegex) {\n    const url = this._getContextUrl();\n    if (!url) return false;\n    const pathOnly = url.replace(/^https?:\\/\\//, \"\").replace(/^[^/]*\\//, \"/\");\n    if (urlRegex.test(url)) return true;\n    if (urlRegex.test(pathOnly)) return true;\n    return false;\n  }\n  _hasGroupOverlap(expGroups) {\n    const groups = this._ctx.groups || {};\n    for (let i = 0; i < expGroups.length; i++) {\n      if (groups[expGroups[i]]) return true;\n    }\n    return false;\n  }\n  _applyDOMChanges(changes) {\n    if (!isBrowser) return;\n    const undo = [];\n    if (changes.css) {\n      const s = document.createElement(\"style\");\n      s.innerHTML = changes.css;\n      document.head.appendChild(s);\n      undo.push(() => s.remove());\n    }\n    if (changes.js) {\n      const script = document.createElement(\"script\");\n      script.innerHTML = changes.js;\n      document.head.appendChild(script);\n      undo.push(() => script.remove());\n    }\n    if (changes.domMutations) {\n      changes.domMutations.forEach(mutation => {\n        undo.push(dom_mutator__WEBPACK_IMPORTED_MODULE_0__[\"default\"].declarative(mutation).revert);\n      });\n    }\n    return () => {\n      undo.forEach(fn => fn());\n    };\n  }\n  _deriveStickyBucketIdentifierAttributes(data) {\n    const attributes = new Set();\n    const features = data && data.features ? data.features : this.getFeatures();\n    const experiments = data && data.experiments ? data.experiments : this.getExperiments();\n    Object.keys(features).forEach(id => {\n      const feature = features[id];\n      if (feature.rules) {\n        for (const rule of feature.rules) {\n          if (rule.variations) {\n            attributes.add(rule.hashAttribute || \"id\");\n            if (rule.fallbackAttribute) {\n              attributes.add(rule.fallbackAttribute);\n            }\n          }\n        }\n      }\n    });\n    experiments.map(experiment => {\n      attributes.add(experiment.hashAttribute || \"id\");\n      if (experiment.fallbackAttribute) {\n        attributes.add(experiment.fallbackAttribute);\n      }\n    });\n    return Array.from(attributes);\n  }\n  async refreshStickyBuckets(data) {\n    if (this._ctx.stickyBucketService) {\n      const attributes = this._getStickyBucketAttributes(data);\n      this._ctx.stickyBucketAssignmentDocs = await this._ctx.stickyBucketService.getAllAssignments(attributes);\n    }\n  }\n  _getStickyBucketAssignments() {\n    const mergedAssignments = {};\n    Object.values(this._ctx.stickyBucketAssignmentDocs || {}).forEach(doc => {\n      if (doc.assignments) Object.assign(mergedAssignments, doc.assignments);\n    });\n    return mergedAssignments;\n  }\n  _getStickyBucketVariation(experimentKey, experimentBucketVersion, minExperimentBucketVersion, meta) {\n    experimentBucketVersion = experimentBucketVersion || 0;\n    minExperimentBucketVersion = minExperimentBucketVersion || 0;\n    meta = meta || [];\n    const id = this._getStickyBucketExperimentKey(experimentKey, experimentBucketVersion);\n    const assignments = this._getStickyBucketAssignments();\n\n    // users with any blocked bucket version (0 to minExperimentBucketVersion) are excluded from the test\n    if (minExperimentBucketVersion > 0) {\n      for (let i = 0; i <= minExperimentBucketVersion; i++) {\n        const blockedKey = this._getStickyBucketExperimentKey(experimentKey, i);\n        if (assignments[blockedKey] !== undefined) {\n          return {\n            variation: -1,\n            versionIsBlocked: true\n          };\n        }\n      }\n    }\n    const variationKey = assignments[id];\n    if (variationKey === undefined)\n      // no assignment found\n      return {\n        variation: -1\n      };\n    const variation = meta.findIndex(m => m.key === variationKey);\n    if (variation < 0)\n      // invalid assignment, treat as \"no assignment found\"\n      return {\n        variation: -1\n      };\n    return {\n      variation\n    };\n  }\n  _getStickyBucketExperimentKey(experimentKey, experimentBucketVersion) {\n    experimentBucketVersion = experimentBucketVersion || 0;\n    return \"\".concat(experimentKey, \"__\").concat(experimentBucketVersion);\n  }\n  _getStickyBucketAttributes(data) {\n    const attributes = {};\n    this._ctx.stickyBucketIdentifierAttributes = !this._ctx.stickyBucketIdentifierAttributes ? this._deriveStickyBucketIdentifierAttributes(data) : this._ctx.stickyBucketIdentifierAttributes;\n    this._ctx.stickyBucketIdentifierAttributes.forEach(attr => {\n      const {\n        hashValue\n      } = this._getHashAttribute(attr);\n      attributes[attr] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.toString)(hashValue);\n    });\n    return attributes;\n  }\n  _generateStickyBucketAssignmentDoc(attributeName, attributeValue, assignments) {\n    const key = \"\".concat(attributeName, \"||\").concat(attributeValue);\n    const existingAssignments = this._ctx.stickyBucketAssignmentDocs && this._ctx.stickyBucketAssignmentDocs[key] ? this._ctx.stickyBucketAssignmentDocs[key].assignments || {} : {};\n    const newAssignments = {\n      ...existingAssignments,\n      ...assignments\n    };\n    const changed = JSON.stringify(existingAssignments) !== JSON.stringify(newAssignments);\n    return {\n      key,\n      doc: {\n        attributeName,\n        attributeValue,\n        assignments: newAssignments\n      },\n      changed\n    };\n  }\n}\n//# sourceMappingURL=GrowthBook.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bncm93dGhib29rK2dyb3d0aGJvb2tAMC4zMi4wL25vZGVfbW9kdWxlcy9AZ3Jvd3RoYm9vay9ncm93dGhib29rL2Rpc3QvZXNtL0dyb3d0aEJvb2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUM7QUFDeUo7QUFDL0k7QUFDb0M7QUFDL0U7QUFDQSxvQkFBb0IscURBQWM7QUFDM0I7QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4REFBUztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvRUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOENBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4Q0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4Q0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsOENBQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFXO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUFJO0FBQ2xCO0FBQ0EsbUJBQW1CLDhDQUFPO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLHdEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxnQkFBZ0IsMkNBQUk7QUFDcEI7QUFDQSxzQ0FBc0MsOENBQU87QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDZEQUFzQjtBQUM3QztBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUSxrQ0FBa0Msa0RBQVc7QUFDckQsUUFBUSxLQUFxQztBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGlEQUFVO0FBQzNDLFFBQVEsS0FBcUM7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLG9EQUFhO0FBQ2hELE1BQU0sS0FBcUM7QUFDM0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGNBQWMsMkNBQUk7QUFDbEI7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzREFBZTtBQUN6RCxpQkFBaUIsc0RBQWU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUF5RCwrQ0FBUTtBQUN6RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EseUJBQXlCLG1EQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtREFBTTtBQUN4QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QiwrQ0FBUTtBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTEFBZ0w7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZ3Jvd3RoYm9vaytncm93dGhib29rQDAuMzIuMC9ub2RlX21vZHVsZXMvQGdyb3d0aGJvb2svZ3Jvd3RoYm9vay9kaXN0L2VzbS9Hcm93dGhCb29rLmpzPzI3ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG11dGF0ZSBmcm9tIFwiZG9tLW11dGF0b3JcIjtcbmltcG9ydCB7IGNob29zZVZhcmlhdGlvbiwgZGVjcnlwdCwgZ2V0QnVja2V0UmFuZ2VzLCBnZXRRdWVyeVN0cmluZ092ZXJyaWRlLCBnZXRVcmxSZWdFeHAsIGhhc2gsIGluTmFtZXNwYWNlLCBpblJhbmdlLCBpc0luY2x1ZGVkLCBpc1VSTFRhcmdldGVkLCBsb2FkU0RLVmVyc2lvbiwgdG9TdHJpbmcgfSBmcm9tIFwiLi91dGlsXCI7XG5pbXBvcnQgeyBldmFsQ29uZGl0aW9uIH0gZnJvbSBcIi4vbW9uZ3J1bGVcIjtcbmltcG9ydCB7IHJlZnJlc2hGZWF0dXJlcywgc3Vic2NyaWJlLCB1bnN1YnNjcmliZSB9IGZyb20gXCIuL2ZlYXR1cmUtcmVwb3NpdG9yeVwiO1xuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBTREtfVkVSU0lPTiA9IGxvYWRTREtWZXJzaW9uKCk7XG5leHBvcnQgY2xhc3MgR3Jvd3RoQm9vayB7XG4gIC8vIGNvbnRleHQgaXMgdGVjaG5pY2FsbHkgcHJpdmF0ZSwgYnV0IHNvbWUgdG9vbHMgZGVwZW5kIG9uIGl0IHNvIHdlIGNhbid0IG1hbmdsZSB0aGUgbmFtZVxuICAvLyBfY3R4IGJlbG93IGlzIGEgY2xvbmUgb2YgdGhpcyBwcm9wZXJ0eSB0aGF0IHdlIHVzZSBpbnRlcm5hbGx5XG5cbiAgLy8gUHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXCJfXCIgYXJlIG1hbmdsZWQgYnkgVGVyc2VyIChzYXZlcyB+MTUwIGJ5dGVzKVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB7fTtcbiAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBhbGwgaW5pdGlhbGl6ZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgYWJvdmVcbiAgICAvLyBUaGlzIHNhdmVzIH44MCBieXRlcyBpbiB0aGUgZmluYWwgb3V0cHV0XG4gICAgdGhpcy52ZXJzaW9uID0gU0RLX1ZFUlNJT047XG4gICAgdGhpcy5fY3R4ID0gdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fdHJhY2tlZEV4cGVyaW1lbnRzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3RyYWNrZWRGZWF0dXJlcyA9IHt9O1xuICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3J0UXVldWUgPSBbXTtcbiAgICB0aGlzLl9ydFRpbWVyID0gMDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fYXNzaWduZWQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fZm9yY2VkRmVhdHVyZVZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9hdHRyaWJ1dGVPdmVycmlkZXMgPSB7fTtcbiAgICB0aGlzLl9hY3RpdmVBdXRvRXhwZXJpbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdHJpZ2dlcmVkRXhwS2V5cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9sb2FkRmVhdHVyZXNDYWxsZWQgPSBmYWxzZTtcbiAgICBpZiAoY29udGV4dC5yZW1vdGVFdmFsKSB7XG4gICAgICBpZiAoY29udGV4dC5kZWNyeXB0aW9uS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gaXMgbm90IGF2YWlsYWJsZSBmb3IgcmVtb3RlRXZhbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY29udGV4dC5jbGllbnRLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjbGllbnRLZXlcIik7XG4gICAgICB9XG4gICAgICBsZXQgaXNHYkhvc3QgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlzR2JIb3N0ID0gISFuZXcgVVJMKGNvbnRleHQuYXBpSG9zdCB8fCBcIlwiKS5ob3N0bmFtZS5tYXRjaCgvZ3Jvd3RoYm9va1xcLmlvJC9pKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlIGludmFsaWQgVVJMc1xuICAgICAgfVxuICAgICAgaWYgKGlzR2JIb3N0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgcmVtb3RlRXZhbCBvbiBHcm93dGhCb29rIENsb3VkXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dC5jYWNoZUtleUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FjaGVLZXlBdHRyaWJ1dGVzIGFyZSBvbmx5IHVzZWQgZm9yIHJlbW90ZUV2YWxcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmZlYXR1cmVzKSB7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzQnJvd3NlciAmJiBjb250ZXh0LmVuYWJsZURldk1vZGUpIHtcbiAgICAgIHdpbmRvdy5fZ3Jvd3RoYm9vayA9IHRoaXM7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImdibG9hZGVkXCIpKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZXhwZXJpbWVudHMpIHtcbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fdXBkYXRlQWxsQXV0b0V4cGVyaW1lbnRzKCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmNsaWVudEtleSAmJiAhY29udGV4dC5yZW1vdGVFdmFsKSB7XG4gICAgICB0aGlzLl9yZWZyZXNoKHt9LCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvYWRGZWF0dXJlcyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRvUmVmcmVzaCkge1xuICAgICAgLy8gaW50ZXJwcmV0IGRlcHJlY2F0ZWQgYXV0b1JlZnJlc2ggb3B0aW9uIGFzIHN1YnNjcmliZVRvQ2hhbmdlc1xuICAgICAgdGhpcy5fY3R4LnN1YnNjcmliZVRvQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRGZWF0dXJlc0NhbGxlZCA9IHRydWU7XG4gICAgYXdhaXQgdGhpcy5fcmVmcmVzaChvcHRpb25zLCB0cnVlLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fY2FuU3Vic2NyaWJlKCkpIHtcbiAgICAgIHN1YnNjcmliZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVmcmVzaEZlYXR1cmVzKG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWZyZXNoKG9wdGlvbnMsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICBnZXRBcGlJbmZvKCkge1xuICAgIHJldHVybiBbdGhpcy5nZXRBcGlIb3N0cygpLmFwaUhvc3QsIHRoaXMuZ2V0Q2xpZW50S2V5KCldO1xuICB9XG4gIGdldEFwaUhvc3RzKCkge1xuICAgIGNvbnN0IGRlZmF1bHRIb3N0ID0gdGhpcy5fY3R4LmFwaUhvc3QgfHwgXCJodHRwczovL2Nkbi5ncm93dGhib29rLmlvXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwaUhvc3Q6IGRlZmF1bHRIb3N0LnJlcGxhY2UoL1xcLyokLywgXCJcIiksXG4gICAgICBzdHJlYW1pbmdIb3N0OiAodGhpcy5fY3R4LnN0cmVhbWluZ0hvc3QgfHwgZGVmYXVsdEhvc3QpLnJlcGxhY2UoL1xcLyokLywgXCJcIiksXG4gICAgICBhcGlSZXF1ZXN0SGVhZGVyczogdGhpcy5fY3R4LmFwaUhvc3RSZXF1ZXN0SGVhZGVycyxcbiAgICAgIHN0cmVhbWluZ0hvc3RSZXF1ZXN0SGVhZGVyczogdGhpcy5fY3R4LnN0cmVhbWluZ0hvc3RSZXF1ZXN0SGVhZGVyc1xuICAgIH07XG4gIH1cbiAgZ2V0Q2xpZW50S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9jdHguY2xpZW50S2V5IHx8IFwiXCI7XG4gIH1cbiAgaXNSZW1vdGVFdmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHgucmVtb3RlRXZhbCB8fCBmYWxzZTtcbiAgfVxuICBnZXRDYWNoZUtleUF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N0eC5jYWNoZUtleUF0dHJpYnV0ZXM7XG4gIH1cbiAgYXN5bmMgX3JlZnJlc2gob3B0aW9ucywgYWxsb3dTdGFsZSwgdXBkYXRlSW5zdGFuY2UpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIXRoaXMuX2N0eC5jbGllbnRLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY2xpZW50S2V5XCIpO1xuICAgIH1cbiAgICBhd2FpdCByZWZyZXNoRmVhdHVyZXModGhpcywgb3B0aW9ucy50aW1lb3V0LCBvcHRpb25zLnNraXBDYWNoZSB8fCB0aGlzLl9jdHguZW5hYmxlRGV2TW9kZSwgYWxsb3dTdGFsZSwgdXBkYXRlSW5zdGFuY2UsIHRoaXMuX2N0eC5iYWNrZ3JvdW5kU3luYyAhPT0gZmFsc2UpO1xuICB9XG4gIF9yZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlcigpO1xuICAgIH1cbiAgfVxuICBzZXRGZWF0dXJlcyhmZWF0dXJlcykge1xuICAgIHRoaXMuX2N0eC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICB9XG4gIGFzeW5jIHNldEVuY3J5cHRlZEZlYXR1cmVzKGVuY3J5cHRlZFN0cmluZywgZGVjcnlwdGlvbktleSwgc3VidGxlKSB7XG4gICAgY29uc3QgZmVhdHVyZXNKU09OID0gYXdhaXQgZGVjcnlwdChlbmNyeXB0ZWRTdHJpbmcsIGRlY3J5cHRpb25LZXkgfHwgdGhpcy5fY3R4LmRlY3J5cHRpb25LZXksIHN1YnRsZSk7XG4gICAgdGhpcy5zZXRGZWF0dXJlcyhKU09OLnBhcnNlKGZlYXR1cmVzSlNPTikpO1xuICB9XG4gIHNldEV4cGVyaW1lbnRzKGV4cGVyaW1lbnRzKSB7XG4gICAgdGhpcy5fY3R4LmV4cGVyaW1lbnRzID0gZXhwZXJpbWVudHM7XG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlQWxsQXV0b0V4cGVyaW1lbnRzKCk7XG4gIH1cbiAgYXN5bmMgc2V0RW5jcnlwdGVkRXhwZXJpbWVudHMoZW5jcnlwdGVkU3RyaW5nLCBkZWNyeXB0aW9uS2V5LCBzdWJ0bGUpIHtcbiAgICBjb25zdCBleHBlcmltZW50c0pTT04gPSBhd2FpdCBkZWNyeXB0KGVuY3J5cHRlZFN0cmluZywgZGVjcnlwdGlvbktleSB8fCB0aGlzLl9jdHguZGVjcnlwdGlvbktleSwgc3VidGxlKTtcbiAgICB0aGlzLnNldEV4cGVyaW1lbnRzKEpTT04ucGFyc2UoZXhwZXJpbWVudHNKU09OKSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdFBheWxvYWQoZGF0YSwgZGVjcnlwdGlvbktleSwgc3VidGxlKSB7XG4gICAgaWYgKGRhdGEuZW5jcnlwdGVkRmVhdHVyZXMpIHtcbiAgICAgIGRhdGEuZmVhdHVyZXMgPSBKU09OLnBhcnNlKGF3YWl0IGRlY3J5cHQoZGF0YS5lbmNyeXB0ZWRGZWF0dXJlcywgZGVjcnlwdGlvbktleSB8fCB0aGlzLl9jdHguZGVjcnlwdGlvbktleSwgc3VidGxlKSk7XG4gICAgICBkZWxldGUgZGF0YS5lbmNyeXB0ZWRGZWF0dXJlcztcbiAgICB9XG4gICAgaWYgKGRhdGEuZW5jcnlwdGVkRXhwZXJpbWVudHMpIHtcbiAgICAgIGRhdGEuZXhwZXJpbWVudHMgPSBKU09OLnBhcnNlKGF3YWl0IGRlY3J5cHQoZGF0YS5lbmNyeXB0ZWRFeHBlcmltZW50cywgZGVjcnlwdGlvbktleSB8fCB0aGlzLl9jdHguZGVjcnlwdGlvbktleSwgc3VidGxlKSk7XG4gICAgICBkZWxldGUgZGF0YS5lbmNyeXB0ZWRFeHBlcmltZW50cztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5fY3R4LmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIGlmICh0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZSkge1xuICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoU3RpY2t5QnVja2V0cygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3R4LnJlbW90ZUV2YWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hGb3JSZW1vdGVFdmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIHRoaXMuX3VwZGF0ZUFsbEF1dG9FeHBlcmltZW50cygpO1xuICB9XG4gIGFzeW5jIHNldEF0dHJpYnV0ZU92ZXJyaWRlcyhvdmVycmlkZXMpIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVPdmVycmlkZXMgPSBvdmVycmlkZXM7XG4gICAgaWYgKHRoaXMuX2N0eC5zdGlja3lCdWNrZXRTZXJ2aWNlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlZnJlc2hTdGlja3lCdWNrZXRzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jdHgucmVtb3RlRXZhbCkge1xuICAgICAgYXdhaXQgdGhpcy5fcmVmcmVzaEZvclJlbW90ZUV2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgdGhpcy5fdXBkYXRlQWxsQXV0b0V4cGVyaW1lbnRzKCk7XG4gIH1cbiAgYXN5bmMgc2V0Rm9yY2VkVmFyaWF0aW9ucyh2YXJzKSB7XG4gICAgdGhpcy5fY3R4LmZvcmNlZFZhcmlhdGlvbnMgPSB2YXJzIHx8IHt9O1xuICAgIGlmICh0aGlzLl9jdHgucmVtb3RlRXZhbCkge1xuICAgICAgYXdhaXQgdGhpcy5fcmVmcmVzaEZvclJlbW90ZUV2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgdGhpcy5fdXBkYXRlQWxsQXV0b0V4cGVyaW1lbnRzKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgc2V0Rm9yY2VkRmVhdHVyZXMobWFwKSB7XG4gICAgdGhpcy5fZm9yY2VkRmVhdHVyZVZhbHVlcyA9IG1hcDtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgfVxuICBhc3luYyBzZXRVUkwodXJsKSB7XG4gICAgdGhpcy5fY3R4LnVybCA9IHVybDtcbiAgICBpZiAodGhpcy5fY3R4LnJlbW90ZUV2YWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hGb3JSZW1vdGVFdmFsKCk7XG4gICAgICB0aGlzLl91cGRhdGVBbGxBdXRvRXhwZXJpbWVudHModHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUFsbEF1dG9FeHBlcmltZW50cyh0cnVlKTtcbiAgfVxuICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLl9jdHguYXR0cmlidXRlcyxcbiAgICAgIC4uLnRoaXMuX2F0dHJpYnV0ZU92ZXJyaWRlc1xuICAgIH07XG4gIH1cbiAgZ2V0Rm9yY2VkVmFyaWF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4LmZvcmNlZFZhcmlhdGlvbnMgfHwge307XG4gIH1cbiAgZ2V0Rm9yY2VkRmVhdHVyZXMoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlZEZlYXR1cmVWYWx1ZXMgfHwgbmV3IE1hcCgpO1xuICB9XG4gIGdldFN0aWNreUJ1Y2tldEFzc2lnbm1lbnREb2NzKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHguc3RpY2t5QnVja2V0QXNzaWdubWVudERvY3MgfHwge307XG4gIH1cbiAgZ2V0VXJsKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHgudXJsIHx8IFwiXCI7XG4gIH1cbiAgZ2V0RmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N0eC5mZWF0dXJlcyB8fCB7fTtcbiAgfVxuICBnZXRFeHBlcmltZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4LmV4cGVyaW1lbnRzIHx8IFtdO1xuICB9XG4gIHN1YnNjcmliZShjYikge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGNiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5kZWxldGUoY2IpO1xuICAgIH07XG4gIH1cbiAgX2NhblN1YnNjcmliZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4LmJhY2tncm91bmRTeW5jICE9PSBmYWxzZSAmJiB0aGlzLl9jdHguc3Vic2NyaWJlVG9DaGFuZ2VzO1xuICB9XG4gIGFzeW5jIF9yZWZyZXNoRm9yUmVtb3RlRXZhbCgpIHtcbiAgICBpZiAoIXRoaXMuX2N0eC5yZW1vdGVFdmFsKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLl9sb2FkRmVhdHVyZXNDYWxsZWQpIHJldHVybjtcbiAgICBhd2FpdCB0aGlzLl9yZWZyZXNoKHt9LCBmYWxzZSwgdHJ1ZSkuY2F0Y2goKCkgPT4ge1xuICAgICAgLy8gSWdub3JlIGVycm9yc1xuICAgIH0pO1xuICB9XG4gIGdldEFsbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5fYXNzaWduZWQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gUmVsZWFzZSByZWZlcmVuY2VzIHRvIHNhdmUgbWVtb3J5XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMuX2Fzc2lnbmVkLmNsZWFyKCk7XG4gICAgdGhpcy5fdHJhY2tlZEV4cGVyaW1lbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5fdHJhY2tlZEZlYXR1cmVzID0ge307XG4gICAgdGhpcy5fcnRRdWV1ZSA9IFtdO1xuICAgIGlmICh0aGlzLl9ydFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnRUaW1lcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHRoaXMpO1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgd2luZG93Ll9ncm93dGhib29rID09PSB0aGlzKSB7XG4gICAgICBkZWxldGUgd2luZG93Ll9ncm93dGhib29rO1xuICAgIH1cblxuICAgIC8vIFVuZG8gYW55IGFjdGl2ZSBhdXRvIGV4cGVyaW1lbnRzXG4gICAgdGhpcy5fYWN0aXZlQXV0b0V4cGVyaW1lbnRzLmZvckVhY2goZXhwID0+IHtcbiAgICAgIGV4cC51bmRvKCk7XG4gICAgfSk7XG4gICAgdGhpcy5fYWN0aXZlQXV0b0V4cGVyaW1lbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5fdHJpZ2dlcmVkRXhwS2V5cy5jbGVhcigpO1xuICB9XG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBmb3JjZVZhcmlhdGlvbihrZXksIHZhcmlhdGlvbikge1xuICAgIHRoaXMuX2N0eC5mb3JjZWRWYXJpYXRpb25zID0gdGhpcy5fY3R4LmZvcmNlZFZhcmlhdGlvbnMgfHwge307XG4gICAgdGhpcy5fY3R4LmZvcmNlZFZhcmlhdGlvbnNba2V5XSA9IHZhcmlhdGlvbjtcbiAgICBpZiAodGhpcy5fY3R4LnJlbW90ZUV2YWwpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2hGb3JSZW1vdGVFdmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUFsbEF1dG9FeHBlcmltZW50cygpO1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICB9XG4gIHJ1bihleHBlcmltZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcnVuKGV4cGVyaW1lbnQsIG51bGwpO1xuICAgIHRoaXMuX2ZpcmVTdWJzY3JpcHRpb25zKGV4cGVyaW1lbnQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmlnZ2VyRXhwZXJpbWVudChrZXkpIHtcbiAgICB0aGlzLl90cmlnZ2VyZWRFeHBLZXlzLmFkZChrZXkpO1xuICAgIGlmICghdGhpcy5fY3R4LmV4cGVyaW1lbnRzKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBleHBlcmltZW50cyA9IHRoaXMuX2N0eC5leHBlcmltZW50cy5maWx0ZXIoZXhwID0+IGV4cC5rZXkgPT09IGtleSk7XG4gICAgcmV0dXJuIGV4cGVyaW1lbnRzLm1hcChleHAgPT4ge1xuICAgICAgaWYgKCFleHAubWFudWFsKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5BdXRvRXhwZXJpbWVudChleHApO1xuICAgIH0pLmZpbHRlcihyZXMgPT4gcmVzICE9PSBudWxsKTtcbiAgfVxuICBfcnVuQXV0b0V4cGVyaW1lbnQoZXhwZXJpbWVudCwgZm9yY2VSZXJ1bikge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fYWN0aXZlQXV0b0V4cGVyaW1lbnRzLmdldChleHBlcmltZW50KTtcblxuICAgIC8vIElmIHRoaXMgaXMgYSBtYW51YWwgZXhwZXJpbWVudCBhbmQgaXQncyBub3QgYWxyZWFkeSBydW5uaW5nLCBza2lwXG4gICAgaWYgKGV4cGVyaW1lbnQubWFudWFsICYmICF0aGlzLl90cmlnZ2VyZWRFeHBLZXlzLmhhcyhleHBlcmltZW50LmtleSkgJiYgIWV4aXN0aW5nKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIFJ1biB0aGUgZXhwZXJpbWVudFxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucnVuKGV4cGVyaW1lbnQpO1xuXG4gICAgLy8gQSBoYXNoIHRvIHF1aWNrbHkgdGVsbCBpZiB0aGUgYXNzaWduZWQgdmFsdWUgY2hhbmdlZFxuICAgIGNvbnN0IHZhbHVlSGFzaCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC52YWx1ZSk7XG5cbiAgICAvLyBJZiB0aGUgY2hhbmdlcyBhcmUgYWxyZWFkeSBhY3RpdmUsIG5vIG5lZWQgdG8gcmUtYXBwbHkgdGhlbVxuICAgIGlmICghZm9yY2VSZXJ1biAmJiByZXN1bHQuaW5FeHBlcmltZW50ICYmIGV4aXN0aW5nICYmIGV4aXN0aW5nLnZhbHVlSGFzaCA9PT0gdmFsdWVIYXNoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFVuZG8gYW55IGV4aXN0aW5nIGNoYW5nZXNcbiAgICBpZiAoZXhpc3RpbmcpIHRoaXMuX3VuZG9BY3RpdmVBdXRvRXhwZXJpbWVudChleHBlcmltZW50KTtcblxuICAgIC8vIEFwcGx5IG5ldyBjaGFuZ2VzXG4gICAgaWYgKHJlc3VsdC5pbkV4cGVyaW1lbnQpIHtcbiAgICAgIGNvbnN0IHVuZG8gPSB0aGlzLl9hcHBseURPTUNoYW5nZXMocmVzdWx0LnZhbHVlKTtcbiAgICAgIGlmICh1bmRvKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUF1dG9FeHBlcmltZW50cy5zZXQoZXhwZXJpbWVudCwge1xuICAgICAgICAgIHVuZG8sXG4gICAgICAgICAgdmFsdWVIYXNoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF91bmRvQWN0aXZlQXV0b0V4cGVyaW1lbnQoZXhwKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2FjdGl2ZUF1dG9FeHBlcmltZW50cy5nZXQoZXhwKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgZGF0YS51bmRvKCk7XG4gICAgICB0aGlzLl9hY3RpdmVBdXRvRXhwZXJpbWVudHMuZGVsZXRlKGV4cCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVBbGxBdXRvRXhwZXJpbWVudHMoZm9yY2VSZXJ1bikge1xuICAgIGNvbnN0IGV4cGVyaW1lbnRzID0gdGhpcy5fY3R4LmV4cGVyaW1lbnRzIHx8IFtdO1xuXG4gICAgLy8gU3RvcCBhbnkgZXhwZXJpbWVudHMgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlZmluZWRcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChleHBlcmltZW50cyk7XG4gICAgdGhpcy5fYWN0aXZlQXV0b0V4cGVyaW1lbnRzLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgIGlmICgha2V5cy5oYXMoaykpIHtcbiAgICAgICAgdi51bmRvKCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUF1dG9FeHBlcmltZW50cy5kZWxldGUoayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZS1ydW4gYWxsIG5ldy91cGRhdGVkIGV4cGVyaW1lbnRzXG4gICAgZXhwZXJpbWVudHMuZm9yRWFjaChleHAgPT4ge1xuICAgICAgdGhpcy5fcnVuQXV0b0V4cGVyaW1lbnQoZXhwLCBmb3JjZVJlcnVuKTtcbiAgICB9KTtcbiAgfVxuICBfZmlyZVN1YnNjcmlwdGlvbnMoZXhwZXJpbWVudCwgcmVzdWx0KSB7XG4gICAgY29uc3Qga2V5ID0gZXhwZXJpbWVudC5rZXk7XG5cbiAgICAvLyBJZiBhc3NpZ25lZCB2YXJpYXRpb24gaGFzIGNoYW5nZWQsIGZpcmUgc3Vic2NyaXB0aW9uc1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLl9hc3NpZ25lZC5nZXQoa2V5KTtcbiAgICAvLyBUT0RPOiB3aGF0IGlmIHRoZSBleHBlcmltZW50IGRlZmluaXRpb24gaGFzIGNoYW5nZWQ/XG4gICAgaWYgKCFwcmV2IHx8IHByZXYucmVzdWx0LmluRXhwZXJpbWVudCAhPT0gcmVzdWx0LmluRXhwZXJpbWVudCB8fCBwcmV2LnJlc3VsdC52YXJpYXRpb25JZCAhPT0gcmVzdWx0LnZhcmlhdGlvbklkKSB7XG4gICAgICB0aGlzLl9hc3NpZ25lZC5zZXQoa2V5LCB7XG4gICAgICAgIGV4cGVyaW1lbnQsXG4gICAgICAgIHJlc3VsdFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goY2IgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiKGV4cGVyaW1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3RyYWNrRmVhdHVyZVVzYWdlKGtleSwgcmVzKSB7XG4gICAgLy8gRG9uJ3QgdHJhY2sgZmVhdHVyZSB1c2FnZSB0aGF0IHdhcyBmb3JjZWQgdmlhIGFuIG92ZXJyaWRlXG4gICAgaWYgKHJlcy5zb3VyY2UgPT09IFwib3ZlcnJpZGVcIikgcmV0dXJuO1xuXG4gICAgLy8gT25seSB0cmFjayBhIGZlYXR1cmUgb25jZSwgdW5sZXNzIHRoZSBhc3NpZ25lZCB2YWx1ZSBjaGFuZ2VkXG4gICAgY29uc3Qgc3RyaW5naWZpZWRWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHJlcy52YWx1ZSk7XG4gICAgaWYgKHRoaXMuX3RyYWNrZWRGZWF0dXJlc1trZXldID09PSBzdHJpbmdpZmllZFZhbHVlKSByZXR1cm47XG4gICAgdGhpcy5fdHJhY2tlZEZlYXR1cmVzW2tleV0gPSBzdHJpbmdpZmllZFZhbHVlO1xuXG4gICAgLy8gRmlyZSB1c2VyLXN1cHBsaWVkIGNhbGxiYWNrXG4gICAgaWYgKHRoaXMuX2N0eC5vbkZlYXR1cmVVc2FnZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY3R4Lm9uRmVhdHVyZVVzYWdlKGtleSwgcmVzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWdub3JlIGZlYXR1cmUgdXNhZ2UgY2FsbGJhY2sgZXJyb3JzXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW4gYnJvd3NlciBlbnZpcm9ubWVudHMsIHF1ZXVlIHVwIGZlYXR1cmUgdXNhZ2UgdG8gYmUgdHJhY2tlZCBpbiBiYXRjaGVzXG4gICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXdpbmRvdy5mZXRjaCkgcmV0dXJuO1xuICAgIHRoaXMuX3J0UXVldWUucHVzaCh7XG4gICAgICBrZXksXG4gICAgICBvbjogcmVzLm9uXG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9ydFRpbWVyKSB7XG4gICAgICB0aGlzLl9ydFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBSZXNldCB0aGUgcXVldWVcbiAgICAgICAgdGhpcy5fcnRUaW1lciA9IDA7XG4gICAgICAgIGNvbnN0IHEgPSBbLi4udGhpcy5fcnRRdWV1ZV07XG4gICAgICAgIHRoaXMuX3J0UXVldWUgPSBbXTtcblxuICAgICAgICAvLyBTa2lwIGxvZ2dpbmcgaWYgYSByZWFsLXRpbWUgdXNhZ2Uga2V5IGlzIG5vdCBjb25maWd1cmVkXG4gICAgICAgIGlmICghdGhpcy5fY3R4LnJlYWx0aW1lS2V5KSByZXR1cm47XG4gICAgICAgIHdpbmRvdy5mZXRjaChcImh0dHBzOi8vcnQuZ3Jvd3RoYm9vay5pby8/a2V5PVwiLmNvbmNhdCh0aGlzLl9jdHgucmVhbHRpbWVLZXksIFwiJmV2ZW50cz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShxKSkpLCB7XG4gICAgICAgICAgY2FjaGU6IFwibm8tY2FjaGVcIixcbiAgICAgICAgICBtb2RlOiBcIm5vLWNvcnNcIlxuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gVE9ETzogcmV0cnkgaW4gY2FzZSBvZiBuZXR3b3JrIGVycm9ycz9cbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzLl9jdHgucmVhbHRpbWVJbnRlcnZhbCB8fCAyMDAwKTtcbiAgICB9XG4gIH1cbiAgX2dldEZlYXR1cmVSZXN1bHQoa2V5LCB2YWx1ZSwgc291cmNlLCBydWxlSWQsIGV4cGVyaW1lbnQsIHJlc3VsdCkge1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgb246ICEhdmFsdWUsXG4gICAgICBvZmY6ICF2YWx1ZSxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHJ1bGVJZDogcnVsZUlkIHx8IFwiXCJcbiAgICB9O1xuICAgIGlmIChleHBlcmltZW50KSByZXQuZXhwZXJpbWVudCA9IGV4cGVyaW1lbnQ7XG4gICAgaWYgKHJlc3VsdCkgcmV0LmV4cGVyaW1lbnRSZXN1bHQgPSByZXN1bHQ7XG5cbiAgICAvLyBUcmFjayB0aGUgdXNhZ2Ugb2YgdGhpcyBmZWF0dXJlIGluIHJlYWwtdGltZVxuICAgIHRoaXMuX3RyYWNrRmVhdHVyZVVzYWdlKGtleSwgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGlzT24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbEZlYXR1cmUoa2V5KS5vbjtcbiAgfVxuICBpc09mZihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ldmFsRmVhdHVyZShrZXkpLm9mZjtcbiAgfVxuICBnZXRGZWF0dXJlVmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZXZhbEZlYXR1cmUoa2V5KS52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGV2YWxGZWF0dXJlfVxuICAgKiBAcGFyYW0gaWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBmZWF0dXJlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbEZlYXR1cmUoaWQpO1xuICB9XG4gIGV2YWxGZWF0dXJlKGlkKSB7XG4gICAgLy8gR2xvYmFsIG92ZXJyaWRlXG4gICAgaWYgKHRoaXMuX2ZvcmNlZEZlYXR1cmVWYWx1ZXMuaGFzKGlkKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiR2xvYmFsIG92ZXJyaWRlXCIsIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHZhbHVlOiB0aGlzLl9mb3JjZWRGZWF0dXJlVmFsdWVzLmdldChpZClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEZlYXR1cmVSZXN1bHQoaWQsIHRoaXMuX2ZvcmNlZEZlYXR1cmVWYWx1ZXMuZ2V0KGlkKSwgXCJvdmVycmlkZVwiKTtcbiAgICB9XG5cbiAgICAvLyBVbmtub3duIGZlYXR1cmUgaWRcbiAgICBpZiAoIXRoaXMuX2N0eC5mZWF0dXJlcyB8fCAhdGhpcy5fY3R4LmZlYXR1cmVzW2lkXSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiVW5rbm93biBmZWF0dXJlXCIsIHtcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEZlYXR1cmVSZXN1bHQoaWQsIG51bGwsIFwidW5rbm93bkZlYXR1cmVcIik7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBmZWF0dXJlXG4gICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuX2N0eC5mZWF0dXJlc1tpZF07XG5cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIHJ1bGVzXG4gICAgaWYgKGZlYXR1cmUucnVsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBmZWF0dXJlLnJ1bGVzKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBmaWx0ZXJzIGZvciB3aG8gaXMgaW5jbHVkZWQgKGUuZy4gbmFtZXNwYWNlcylcbiAgICAgICAgaWYgKHJ1bGUuZmlsdGVycyAmJiB0aGlzLl9pc0ZpbHRlcmVkT3V0KHJ1bGUuZmlsdGVycykpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5sb2coXCJTa2lwIHJ1bGUgYmVjYXVzZSBvZiBmaWx0ZXJzXCIsIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcnVsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmVhdHVyZSB2YWx1ZSBpcyBiZWluZyBmb3JjZWRcbiAgICAgICAgaWYgKFwiZm9yY2VcIiBpbiBydWxlKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBhIGNvbmRpdGlvbmFsIHJ1bGUsIHNraXAgaWYgdGhlIGNvbmRpdGlvbiBkb2Vzbid0IHBhc3NcbiAgICAgICAgICBpZiAocnVsZS5jb25kaXRpb24gJiYgIXRoaXMuX2NvbmRpdGlvblBhc3NlcyhydWxlLmNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIlNraXAgcnVsZSBiZWNhdXNlIG9mIGNvbmRpdGlvbiBmZlwiLCB7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBydWxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwZXJjZW50YWdlIHJvbGxvdXQsIHNraXAgaWYgbm90IGluY2x1ZGVkXG4gICAgICAgICAgaWYgKCF0aGlzLl9pc0luY2x1ZGVkSW5Sb2xsb3V0KHJ1bGUuc2VlZCB8fCBpZCwgcnVsZS5oYXNoQXR0cmlidXRlLCB0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZSAmJiAhcnVsZS5kaXNhYmxlU3RpY2t5QnVja2V0aW5nID8gcnVsZS5mYWxsYmFja0F0dHJpYnV0ZSA6IHVuZGVmaW5lZCwgcnVsZS5yYW5nZSwgcnVsZS5jb3ZlcmFnZSwgcnVsZS5oYXNoVmVyc2lvbikpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIlNraXAgcnVsZSBiZWNhdXNlIHVzZXIgbm90IGluY2x1ZGVkIGluIHJvbGxvdXRcIiwge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgcnVsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiRm9yY2UgdmFsdWUgZnJvbSBydWxlXCIsIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcnVsZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSByZW1vdGVseSBldmFsdWF0ZWQgZXhwZXJpbWVudCwgZmlyZSB0aGUgdHJhY2tpbmcgY2FsbGJhY2tzXG4gICAgICAgICAgaWYgKHJ1bGUudHJhY2tzKSB7XG4gICAgICAgICAgICBydWxlLnRyYWNrcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl90cmFjayh0LmV4cGVyaW1lbnQsIHQucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmVhdHVyZVJlc3VsdChpZCwgcnVsZS5mb3JjZSwgXCJmb3JjZVwiLCBydWxlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bGUudmFyaWF0aW9ucykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIlNraXAgaW52YWxpZCBydWxlXCIsIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcnVsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIGV4cGVyaW1lbnQgcnVsZXMsIHJ1biBhbiBleHBlcmltZW50XG4gICAgICAgIGNvbnN0IGV4cCA9IHtcbiAgICAgICAgICB2YXJpYXRpb25zOiBydWxlLnZhcmlhdGlvbnMsXG4gICAgICAgICAga2V5OiBydWxlLmtleSB8fCBpZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJjb3ZlcmFnZVwiIGluIHJ1bGUpIGV4cC5jb3ZlcmFnZSA9IHJ1bGUuY292ZXJhZ2U7XG4gICAgICAgIGlmIChydWxlLndlaWdodHMpIGV4cC53ZWlnaHRzID0gcnVsZS53ZWlnaHRzO1xuICAgICAgICBpZiAocnVsZS5oYXNoQXR0cmlidXRlKSBleHAuaGFzaEF0dHJpYnV0ZSA9IHJ1bGUuaGFzaEF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKHJ1bGUuZmFsbGJhY2tBdHRyaWJ1dGUpIGV4cC5mYWxsYmFja0F0dHJpYnV0ZSA9IHJ1bGUuZmFsbGJhY2tBdHRyaWJ1dGU7XG4gICAgICAgIGlmIChydWxlLmRpc2FibGVTdGlja3lCdWNrZXRpbmcpIGV4cC5kaXNhYmxlU3RpY2t5QnVja2V0aW5nID0gcnVsZS5kaXNhYmxlU3RpY2t5QnVja2V0aW5nO1xuICAgICAgICBpZiAocnVsZS5idWNrZXRWZXJzaW9uICE9PSB1bmRlZmluZWQpIGV4cC5idWNrZXRWZXJzaW9uID0gcnVsZS5idWNrZXRWZXJzaW9uO1xuICAgICAgICBpZiAocnVsZS5taW5CdWNrZXRWZXJzaW9uICE9PSB1bmRlZmluZWQpIGV4cC5taW5CdWNrZXRWZXJzaW9uID0gcnVsZS5taW5CdWNrZXRWZXJzaW9uO1xuICAgICAgICBpZiAocnVsZS5uYW1lc3BhY2UpIGV4cC5uYW1lc3BhY2UgPSBydWxlLm5hbWVzcGFjZTtcbiAgICAgICAgaWYgKHJ1bGUubWV0YSkgZXhwLm1ldGEgPSBydWxlLm1ldGE7XG4gICAgICAgIGlmIChydWxlLnJhbmdlcykgZXhwLnJhbmdlcyA9IHJ1bGUucmFuZ2VzO1xuICAgICAgICBpZiAocnVsZS5uYW1lKSBleHAubmFtZSA9IHJ1bGUubmFtZTtcbiAgICAgICAgaWYgKHJ1bGUucGhhc2UpIGV4cC5waGFzZSA9IHJ1bGUucGhhc2U7XG4gICAgICAgIGlmIChydWxlLnNlZWQpIGV4cC5zZWVkID0gcnVsZS5zZWVkO1xuICAgICAgICBpZiAocnVsZS5oYXNoVmVyc2lvbikgZXhwLmhhc2hWZXJzaW9uID0gcnVsZS5oYXNoVmVyc2lvbjtcbiAgICAgICAgaWYgKHJ1bGUuZmlsdGVycykgZXhwLmZpbHRlcnMgPSBydWxlLmZpbHRlcnM7XG4gICAgICAgIGlmIChydWxlLmNvbmRpdGlvbikgZXhwLmNvbmRpdGlvbiA9IHJ1bGUuY29uZGl0aW9uO1xuXG4gICAgICAgIC8vIE9ubHkgcmV0dXJuIGEgdmFsdWUgaWYgdGhlIHVzZXIgaXMgcGFydCBvZiB0aGUgZXhwZXJpbWVudFxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9ydW4oZXhwLCBpZCk7XG4gICAgICAgIHRoaXMuX2ZpcmVTdWJzY3JpcHRpb25zKGV4cCwgcmVzKTtcbiAgICAgICAgaWYgKHJlcy5pbkV4cGVyaW1lbnQgJiYgIXJlcy5wYXNzdGhyb3VnaCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRGZWF0dXJlUmVzdWx0KGlkLCByZXMudmFsdWUsIFwiZXhwZXJpbWVudFwiLCBydWxlLmlkLCBleHAsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiVXNlIGRlZmF1bHQgdmFsdWVcIiwge1xuICAgICAgaWQsXG4gICAgICB2YWx1ZTogZmVhdHVyZS5kZWZhdWx0VmFsdWVcbiAgICB9KTtcblxuICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgIHJldHVybiB0aGlzLl9nZXRGZWF0dXJlUmVzdWx0KGlkLCBmZWF0dXJlLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGZlYXR1cmUuZGVmYXVsdFZhbHVlLCBcImRlZmF1bHRWYWx1ZVwiKTtcbiAgfVxuICBfaXNJbmNsdWRlZEluUm9sbG91dChzZWVkLCBoYXNoQXR0cmlidXRlLCBmYWxsYmFja0F0dHJpYnV0ZSwgcmFuZ2UsIGNvdmVyYWdlLCBoYXNoVmVyc2lvbikge1xuICAgIGlmICghcmFuZ2UgJiYgY292ZXJhZ2UgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgaGFzaFZhbHVlXG4gICAgfSA9IHRoaXMuX2dldEhhc2hBdHRyaWJ1dGUoaGFzaEF0dHJpYnV0ZSwgZmFsbGJhY2tBdHRyaWJ1dGUpO1xuICAgIGlmICghaGFzaFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG4gPSBoYXNoKHNlZWQsIGhhc2hWYWx1ZSwgaGFzaFZlcnNpb24gfHwgMSk7XG4gICAgaWYgKG4gPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmFuZ2UgPyBpblJhbmdlKG4sIHJhbmdlKSA6IGNvdmVyYWdlICE9PSB1bmRlZmluZWQgPyBuIDw9IGNvdmVyYWdlIDogdHJ1ZTtcbiAgfVxuICBfY29uZGl0aW9uUGFzc2VzKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBldmFsQ29uZGl0aW9uKHRoaXMuZ2V0QXR0cmlidXRlcygpLCBjb25kaXRpb24pO1xuICB9XG4gIF9pc0ZpbHRlcmVkT3V0KGZpbHRlcnMpIHtcbiAgICByZXR1cm4gZmlsdGVycy5zb21lKGZpbHRlciA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhhc2hWYWx1ZVxuICAgICAgfSA9IHRoaXMuX2dldEhhc2hBdHRyaWJ1dGUoZmlsdGVyLmF0dHJpYnV0ZSk7XG4gICAgICBpZiAoIWhhc2hWYWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBuID0gaGFzaChmaWx0ZXIuc2VlZCwgaGFzaFZhbHVlLCBmaWx0ZXIuaGFzaFZlcnNpb24gfHwgMik7XG4gICAgICBpZiAobiA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gIWZpbHRlci5yYW5nZXMuc29tZShyID0+IGluUmFuZ2UobiwgcikpO1xuICAgIH0pO1xuICB9XG4gIF9ydW4oZXhwZXJpbWVudCwgZmVhdHVyZUlkKSB7XG4gICAgY29uc3Qga2V5ID0gZXhwZXJpbWVudC5rZXk7XG4gICAgY29uc3QgbnVtVmFyaWF0aW9ucyA9IGV4cGVyaW1lbnQudmFyaWF0aW9ucy5sZW5ndGg7XG5cbiAgICAvLyAxLiBJZiBleHBlcmltZW50IGhhcyBsZXNzIHRoYW4gMiB2YXJpYXRpb25zLCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAobnVtVmFyaWF0aW9ucyA8IDIpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIkludmFsaWQgZXhwZXJpbWVudFwiLCB7XG4gICAgICAgIGlkOiBrZXlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFJlc3VsdChleHBlcmltZW50LCAtMSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhlIGNvbnRleHQgaXMgZGlzYWJsZWQsIHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl9jdHguZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIkNvbnRleHQgZGlzYWJsZWRcIiwge1xuICAgICAgICBpZDoga2V5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRSZXN1bHQoZXhwZXJpbWVudCwgLTEsIGZhbHNlLCBmZWF0dXJlSWQpO1xuICAgIH1cblxuICAgIC8vIDIuNS4gTWVyZ2UgaW4gZXhwZXJpbWVudCBvdmVycmlkZXMgZnJvbSB0aGUgY29udGV4dFxuICAgIGV4cGVyaW1lbnQgPSB0aGlzLl9tZXJnZU92ZXJyaWRlcyhleHBlcmltZW50KTtcblxuICAgIC8vIDMuIElmIGEgdmFyaWF0aW9uIGlzIGZvcmNlZCBmcm9tIGEgcXVlcnlzdHJpbmcsIHJldHVybiB0aGUgZm9yY2VkIHZhcmlhdGlvblxuICAgIGNvbnN0IHFzT3ZlcnJpZGUgPSBnZXRRdWVyeVN0cmluZ092ZXJyaWRlKGtleSwgdGhpcy5fZ2V0Q29udGV4dFVybCgpLCBudW1WYXJpYXRpb25zKTtcbiAgICBpZiAocXNPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiRm9yY2UgdmlhIHF1ZXJ5c3RyaW5nXCIsIHtcbiAgICAgICAgaWQ6IGtleSxcbiAgICAgICAgdmFyaWF0aW9uOiBxc092ZXJyaWRlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRSZXN1bHQoZXhwZXJpbWVudCwgcXNPdmVycmlkZSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgfVxuXG4gICAgLy8gNC4gSWYgYSB2YXJpYXRpb24gaXMgZm9yY2VkIGluIHRoZSBjb250ZXh0LCByZXR1cm4gdGhlIGZvcmNlZCB2YXJpYXRpb25cbiAgICBpZiAodGhpcy5fY3R4LmZvcmNlZFZhcmlhdGlvbnMgJiYga2V5IGluIHRoaXMuX2N0eC5mb3JjZWRWYXJpYXRpb25zKSB7XG4gICAgICBjb25zdCB2YXJpYXRpb24gPSB0aGlzLl9jdHguZm9yY2VkVmFyaWF0aW9uc1trZXldO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiRm9yY2UgdmlhIGRldiB0b29sc1wiLCB7XG4gICAgICAgIGlkOiBrZXksXG4gICAgICAgIHZhcmlhdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIHZhcmlhdGlvbiwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgfVxuXG4gICAgLy8gNS4gRXhjbHVkZSBpZiBhIGRyYWZ0IGV4cGVyaW1lbnQgb3Igbm90IGFjdGl2ZVxuICAgIGlmIChleHBlcmltZW50LnN0YXR1cyA9PT0gXCJkcmFmdFwiIHx8IGV4cGVyaW1lbnQuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiU2tpcCBiZWNhdXNlIGluYWN0aXZlXCIsIHtcbiAgICAgICAgaWQ6IGtleVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIC0xLCBmYWxzZSwgZmVhdHVyZUlkKTtcbiAgICB9XG5cbiAgICAvLyA2LiBHZXQgdGhlIGhhc2ggYXR0cmlidXRlIGFuZCByZXR1cm4gaWYgZW1wdHlcbiAgICBjb25zdCB7XG4gICAgICBoYXNoQXR0cmlidXRlLFxuICAgICAgaGFzaFZhbHVlXG4gICAgfSA9IHRoaXMuX2dldEhhc2hBdHRyaWJ1dGUoZXhwZXJpbWVudC5oYXNoQXR0cmlidXRlLCB0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZSAmJiAhZXhwZXJpbWVudC5kaXNhYmxlU3RpY2t5QnVja2V0aW5nID8gZXhwZXJpbWVudC5mYWxsYmFja0F0dHJpYnV0ZSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFoYXNoVmFsdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIlNraXAgYmVjYXVzZSBtaXNzaW5nIGhhc2hBdHRyaWJ1dGVcIiwge1xuICAgICAgICBpZDoga2V5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRSZXN1bHQoZXhwZXJpbWVudCwgLTEsIGZhbHNlLCBmZWF0dXJlSWQpO1xuICAgIH1cbiAgICBsZXQgYXNzaWduZWQgPSAtMTtcbiAgICBsZXQgZm91bmRTdGlja3lCdWNrZXQgPSBmYWxzZTtcbiAgICBsZXQgc3RpY2t5QnVja2V0VmVyc2lvbklzQmxvY2tlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZSAmJiAhZXhwZXJpbWVudC5kaXNhYmxlU3RpY2t5QnVja2V0aW5nKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZhcmlhdGlvbixcbiAgICAgICAgdmVyc2lvbklzQmxvY2tlZFxuICAgICAgfSA9IHRoaXMuX2dldFN0aWNreUJ1Y2tldFZhcmlhdGlvbihleHBlcmltZW50LmtleSwgZXhwZXJpbWVudC5idWNrZXRWZXJzaW9uLCBleHBlcmltZW50Lm1pbkJ1Y2tldFZlcnNpb24sIGV4cGVyaW1lbnQubWV0YSk7XG4gICAgICBmb3VuZFN0aWNreUJ1Y2tldCA9IHZhcmlhdGlvbiA+PSAwO1xuICAgICAgYXNzaWduZWQgPSB2YXJpYXRpb247XG4gICAgICBzdGlja3lCdWNrZXRWZXJzaW9uSXNCbG9ja2VkID0gISF2ZXJzaW9uSXNCbG9ja2VkO1xuICAgIH1cblxuICAgIC8vIFNvbWUgY2hlY2tzIGFyZSBub3QgbmVlZGVkIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0aWNreSBidWNrZXRcbiAgICBpZiAoIWZvdW5kU3RpY2t5QnVja2V0KSB7XG4gICAgICAvLyA3LiBFeGNsdWRlIGlmIHVzZXIgaXMgZmlsdGVyZWQgb3V0ICh1c2VkIHRvIGJlIGNhbGxlZCBcIm5hbWVzcGFjZVwiKVxuICAgICAgaWYgKGV4cGVyaW1lbnQuZmlsdGVycykge1xuICAgICAgICBpZiAodGhpcy5faXNGaWx0ZXJlZE91dChleHBlcmltZW50LmZpbHRlcnMpKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiU2tpcCBiZWNhdXNlIG9mIGZpbHRlcnNcIiwge1xuICAgICAgICAgICAgaWQ6IGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRSZXN1bHQoZXhwZXJpbWVudCwgLTEsIGZhbHNlLCBmZWF0dXJlSWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4cGVyaW1lbnQubmFtZXNwYWNlICYmICFpbk5hbWVzcGFjZShoYXNoVmFsdWUsIGV4cGVyaW1lbnQubmFtZXNwYWNlKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5sb2coXCJTa2lwIGJlY2F1c2Ugb2YgbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICBpZDoga2V5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIC0xLCBmYWxzZSwgZmVhdHVyZUlkKTtcbiAgICAgIH1cblxuICAgICAgLy8gNy41LiBFeGNsdWRlIGlmIGV4cGVyaW1lbnQuaW5jbHVkZSByZXR1cm5zIGZhbHNlIG9yIHRocm93c1xuICAgICAgaWYgKGV4cGVyaW1lbnQuaW5jbHVkZSAmJiAhaXNJbmNsdWRlZChleHBlcmltZW50LmluY2x1ZGUpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIlNraXAgYmVjYXVzZSBvZiBpbmNsdWRlIGZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICBpZDoga2V5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIC0xLCBmYWxzZSwgZmVhdHVyZUlkKTtcbiAgICAgIH1cblxuICAgICAgLy8gOC4gRXhjbHVkZSBpZiBjb25kaXRpb24gaXMgZmFsc2VcbiAgICAgIGlmIChleHBlcmltZW50LmNvbmRpdGlvbiAmJiAhdGhpcy5fY29uZGl0aW9uUGFzc2VzKGV4cGVyaW1lbnQuY29uZGl0aW9uKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5sb2coXCJTa2lwIGJlY2F1c2Ugb2YgY29uZGl0aW9uIGV4cFwiLCB7XG4gICAgICAgICAgaWQ6IGtleVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJlc3VsdChleHBlcmltZW50LCAtMSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDguMS4gRXhjbHVkZSBpZiB1c2VyIGlzIG5vdCBpbiBhIHJlcXVpcmVkIGdyb3VwXG4gICAgICBpZiAoZXhwZXJpbWVudC5ncm91cHMgJiYgIXRoaXMuX2hhc0dyb3VwT3ZlcmxhcChleHBlcmltZW50Lmdyb3VwcykpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiU2tpcCBiZWNhdXNlIG9mIGdyb3Vwc1wiLCB7XG4gICAgICAgICAgaWQ6IGtleVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJlc3VsdChleHBlcmltZW50LCAtMSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gOC4yLiBPbGQgc3R5bGUgVVJMIHRhcmdldGluZ1xuICAgIGlmIChleHBlcmltZW50LnVybCAmJiAhdGhpcy5fdXJsSXNWYWxpZChleHBlcmltZW50LnVybCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIlNraXAgYmVjYXVzZSBvZiB1cmxcIiwge1xuICAgICAgICBpZDoga2V5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRSZXN1bHQoZXhwZXJpbWVudCwgLTEsIGZhbHNlLCBmZWF0dXJlSWQpO1xuICAgIH1cblxuICAgIC8vIDguMy4gTmV3LCBtb3JlIHBvd2VyZnVsIFVSTCB0YXJnZXRpbmdcbiAgICBpZiAoZXhwZXJpbWVudC51cmxQYXR0ZXJucyAmJiAhaXNVUkxUYXJnZXRlZCh0aGlzLl9nZXRDb250ZXh0VXJsKCksIGV4cGVyaW1lbnQudXJsUGF0dGVybnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5sb2coXCJTa2lwIGJlY2F1c2Ugb2YgdXJsIHRhcmdldGluZ1wiLCB7XG4gICAgICAgIGlkOiBrZXlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFJlc3VsdChleHBlcmltZW50LCAtMSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgfVxuXG4gICAgLy8gOS4gR2V0IHRoZSB2YXJpYXRpb24gZnJvbSB0aGUgc3RpY2t5IGJ1Y2tldCBvciBnZXQgYnVja2V0IHJhbmdlcyBhbmQgY2hvb3NlIHZhcmlhdGlvblxuICAgIGNvbnN0IG4gPSBoYXNoKGV4cGVyaW1lbnQuc2VlZCB8fCBrZXksIGhhc2hWYWx1ZSwgZXhwZXJpbWVudC5oYXNoVmVyc2lvbiB8fCAxKTtcbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiU2tpcCBiZWNhdXNlIG9mIGludmFsaWQgaGFzaCB2ZXJzaW9uXCIsIHtcbiAgICAgICAgaWQ6IGtleVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIC0xLCBmYWxzZSwgZmVhdHVyZUlkKTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZFN0aWNreUJ1Y2tldCkge1xuICAgICAgY29uc3QgcmFuZ2VzID0gZXhwZXJpbWVudC5yYW5nZXMgfHwgZ2V0QnVja2V0UmFuZ2VzKG51bVZhcmlhdGlvbnMsIGV4cGVyaW1lbnQuY292ZXJhZ2UgPT09IHVuZGVmaW5lZCA/IDEgOiBleHBlcmltZW50LmNvdmVyYWdlLCBleHBlcmltZW50LndlaWdodHMpO1xuICAgICAgYXNzaWduZWQgPSBjaG9vc2VWYXJpYXRpb24obiwgcmFuZ2VzKTtcbiAgICB9XG5cbiAgICAvLyA5LjUgVW5lbnJvbGwgaWYgYW55IHByaW9yIHN0aWNreSBidWNrZXRzIGFyZSBibG9ja2VkIGJ5IHZlcnNpb25cbiAgICBpZiAoc3RpY2t5QnVja2V0VmVyc2lvbklzQmxvY2tlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiU2tpcCBiZWNhdXNlIHN0aWNreSBidWNrZXQgdmVyc2lvbiBpcyBibG9ja2VkXCIsIHtcbiAgICAgICAgaWQ6IGtleVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIC0xLCBmYWxzZSwgZmVhdHVyZUlkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIDEwLiBSZXR1cm4gaWYgbm90IGluIGV4cGVyaW1lbnRcbiAgICBpZiAoYXNzaWduZWQgPCAwKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5sb2coXCJTa2lwIGJlY2F1c2Ugb2YgY292ZXJhZ2VcIiwge1xuICAgICAgICBpZDoga2V5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRSZXN1bHQoZXhwZXJpbWVudCwgLTEsIGZhbHNlLCBmZWF0dXJlSWQpO1xuICAgIH1cblxuICAgIC8vIDExLiBFeHBlcmltZW50IGhhcyBhIGZvcmNlZCB2YXJpYXRpb25cbiAgICBpZiAoXCJmb3JjZVwiIGluIGV4cGVyaW1lbnQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmxvZyhcIkZvcmNlIHZhcmlhdGlvblwiLCB7XG4gICAgICAgIGlkOiBrZXksXG4gICAgICAgIHZhcmlhdGlvbjogZXhwZXJpbWVudC5mb3JjZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIGV4cGVyaW1lbnQuZm9yY2UgPT09IHVuZGVmaW5lZCA/IC0xIDogZXhwZXJpbWVudC5mb3JjZSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgfVxuXG4gICAgLy8gMTIuIEV4Y2x1ZGUgaWYgaW4gUUEgbW9kZVxuICAgIGlmICh0aGlzLl9jdHgucWFNb2RlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5sb2coXCJTa2lwIGJlY2F1c2UgUUEgbW9kZVwiLCB7XG4gICAgICAgIGlkOiBrZXlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFJlc3VsdChleHBlcmltZW50LCAtMSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgfVxuXG4gICAgLy8gMTIuNS4gRXhjbHVkZSBpZiBleHBlcmltZW50IGlzIHN0b3BwZWRcbiAgICBpZiAoZXhwZXJpbWVudC5zdGF0dXMgPT09IFwic3RvcHBlZFwiKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5sb2coXCJTa2lwIGJlY2F1c2Ugc3RvcHBlZFwiLCB7XG4gICAgICAgIGlkOiBrZXlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFJlc3VsdChleHBlcmltZW50LCAtMSwgZmFsc2UsIGZlYXR1cmVJZCk7XG4gICAgfVxuXG4gICAgLy8gMTMuIEJ1aWxkIHRoZSByZXN1bHQgb2JqZWN0XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZ2V0UmVzdWx0KGV4cGVyaW1lbnQsIGFzc2lnbmVkLCB0cnVlLCBmZWF0dXJlSWQsIG4sIGZvdW5kU3RpY2t5QnVja2V0KTtcblxuICAgIC8vIDEzLjUuIFBlcnNpc3Qgc3RpY2t5IGJ1Y2tldFxuICAgIGlmICh0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZSAmJiAhZXhwZXJpbWVudC5kaXNhYmxlU3RpY2t5QnVja2V0aW5nKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoYW5nZWQsXG4gICAgICAgIGtleTogYXR0cktleSxcbiAgICAgICAgZG9jXG4gICAgICB9ID0gdGhpcy5fZ2VuZXJhdGVTdGlja3lCdWNrZXRBc3NpZ25tZW50RG9jKGhhc2hBdHRyaWJ1dGUsIHRvU3RyaW5nKGhhc2hWYWx1ZSksIHtcbiAgICAgICAgW3RoaXMuX2dldFN0aWNreUJ1Y2tldEV4cGVyaW1lbnRLZXkoZXhwZXJpbWVudC5rZXksIGV4cGVyaW1lbnQuYnVja2V0VmVyc2lvbildOiByZXN1bHQua2V5XG4gICAgICB9KTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBsb2NhbCBkb2NzXG4gICAgICAgIHRoaXMuX2N0eC5zdGlja3lCdWNrZXRBc3NpZ25tZW50RG9jcyA9IHRoaXMuX2N0eC5zdGlja3lCdWNrZXRBc3NpZ25tZW50RG9jcyB8fCB7fTtcbiAgICAgICAgdGhpcy5fY3R4LnN0aWNreUJ1Y2tldEFzc2lnbm1lbnREb2NzW2F0dHJLZXldID0gZG9jO1xuICAgICAgICAvLyBzYXZlIGRvY1xuICAgICAgICB0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZS5zYXZlQXNzaWdubWVudHMoZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxNC4gRmlyZSB0aGUgdHJhY2tpbmcgY2FsbGJhY2tcbiAgICB0aGlzLl90cmFjayhleHBlcmltZW50LCByZXN1bHQpO1xuXG4gICAgLy8gMTUuIFJldHVybiB0aGUgcmVzdWx0XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMubG9nKFwiSW4gZXhwZXJpbWVudFwiLCB7XG4gICAgICBpZDoga2V5LFxuICAgICAgdmFyaWF0aW9uOiByZXN1bHQudmFyaWF0aW9uSWRcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxvZyhtc2csIGN0eCkge1xuICAgIGlmICghdGhpcy5kZWJ1ZykgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9jdHgubG9nKSB0aGlzLl9jdHgubG9nKG1zZywgY3R4KTtlbHNlIGNvbnNvbGUubG9nKG1zZywgY3R4KTtcbiAgfVxuICBfdHJhY2soZXhwZXJpbWVudCwgcmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLl9jdHgudHJhY2tpbmdDYWxsYmFjaykgcmV0dXJuO1xuICAgIGNvbnN0IGtleSA9IGV4cGVyaW1lbnQua2V5O1xuXG4gICAgLy8gTWFrZSBzdXJlIGEgdHJhY2tpbmcgY2FsbGJhY2sgaXMgb25seSBmaXJlZCBvbmNlIHBlciB1bmlxdWUgZXhwZXJpbWVudFxuICAgIGNvbnN0IGsgPSByZXN1bHQuaGFzaEF0dHJpYnV0ZSArIHJlc3VsdC5oYXNoVmFsdWUgKyBrZXkgKyByZXN1bHQudmFyaWF0aW9uSWQ7XG4gICAgaWYgKHRoaXMuX3RyYWNrZWRFeHBlcmltZW50cy5oYXMoaykpIHJldHVybjtcbiAgICB0aGlzLl90cmFja2VkRXhwZXJpbWVudHMuYWRkKGspO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jdHgudHJhY2tpbmdDYWxsYmFjayhleHBlcmltZW50LCByZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIF9tZXJnZU92ZXJyaWRlcyhleHBlcmltZW50KSB7XG4gICAgY29uc3Qga2V5ID0gZXhwZXJpbWVudC5rZXk7XG4gICAgY29uc3QgbyA9IHRoaXMuX2N0eC5vdmVycmlkZXM7XG4gICAgaWYgKG8gJiYgb1trZXldKSB7XG4gICAgICBleHBlcmltZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXhwZXJpbWVudCwgb1trZXldKTtcbiAgICAgIGlmICh0eXBlb2YgZXhwZXJpbWVudC51cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZXhwZXJpbWVudC51cmwgPSBnZXRVcmxSZWdFeHAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBleHBlcmltZW50LnVybCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBlcmltZW50O1xuICB9XG4gIF9nZXRIYXNoQXR0cmlidXRlKGF0dHIsIGZhbGxiYWNrKSB7XG4gICAgbGV0IGhhc2hBdHRyaWJ1dGUgPSBhdHRyIHx8IFwiaWRcIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCBoYXNoVmFsdWUgPSBcIlwiO1xuICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVPdmVycmlkZXNbaGFzaEF0dHJpYnV0ZV0pIHtcbiAgICAgIGhhc2hWYWx1ZSA9IHRoaXMuX2F0dHJpYnV0ZU92ZXJyaWRlc1toYXNoQXR0cmlidXRlXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N0eC5hdHRyaWJ1dGVzKSB7XG4gICAgICBoYXNoVmFsdWUgPSB0aGlzLl9jdHguYXR0cmlidXRlc1toYXNoQXR0cmlidXRlXSB8fCBcIlwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY3R4LnVzZXIpIHtcbiAgICAgIGhhc2hWYWx1ZSA9IHRoaXMuX2N0eC51c2VyW2hhc2hBdHRyaWJ1dGVdIHx8IFwiXCI7XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gbWF0Y2gsIHRyeSBmYWxsYmFja1xuICAgIGlmICghaGFzaFZhbHVlICYmIGZhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5fYXR0cmlidXRlT3ZlcnJpZGVzW2ZhbGxiYWNrXSkge1xuICAgICAgICBoYXNoVmFsdWUgPSB0aGlzLl9hdHRyaWJ1dGVPdmVycmlkZXNbZmFsbGJhY2tdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdHguYXR0cmlidXRlcykge1xuICAgICAgICBoYXNoVmFsdWUgPSB0aGlzLl9jdHguYXR0cmlidXRlc1tmYWxsYmFja10gfHwgXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3R4LnVzZXIpIHtcbiAgICAgICAgaGFzaFZhbHVlID0gdGhpcy5fY3R4LnVzZXJbZmFsbGJhY2tdIHx8IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoaGFzaFZhbHVlKSB7XG4gICAgICAgIGhhc2hBdHRyaWJ1dGUgPSBmYWxsYmFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc2hBdHRyaWJ1dGUsXG4gICAgICBoYXNoVmFsdWVcbiAgICB9O1xuICB9XG4gIF9nZXRSZXN1bHQoZXhwZXJpbWVudCwgdmFyaWF0aW9uSW5kZXgsIGhhc2hVc2VkLCBmZWF0dXJlSWQsIGJ1Y2tldCwgc3RpY2t5QnVja2V0VXNlZCkge1xuICAgIGxldCBpbkV4cGVyaW1lbnQgPSB0cnVlO1xuICAgIC8vIElmIGFzc2lnbmVkIHZhcmlhdGlvbiBpcyBub3QgdmFsaWQsIHVzZSB0aGUgYmFzZWxpbmUgYW5kIG1hcmsgdGhlIHVzZXIgYXMgbm90IGluIHRoZSBleHBlcmltZW50XG4gICAgaWYgKHZhcmlhdGlvbkluZGV4IDwgMCB8fCB2YXJpYXRpb25JbmRleCA+PSBleHBlcmltZW50LnZhcmlhdGlvbnMubGVuZ3RoKSB7XG4gICAgICB2YXJpYXRpb25JbmRleCA9IDA7XG4gICAgICBpbkV4cGVyaW1lbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaGFzaEF0dHJpYnV0ZSxcbiAgICAgIGhhc2hWYWx1ZVxuICAgIH0gPSB0aGlzLl9nZXRIYXNoQXR0cmlidXRlKGV4cGVyaW1lbnQuaGFzaEF0dHJpYnV0ZSwgdGhpcy5fY3R4LnN0aWNreUJ1Y2tldFNlcnZpY2UgJiYgIWV4cGVyaW1lbnQuZGlzYWJsZVN0aWNreUJ1Y2tldGluZyA/IGV4cGVyaW1lbnQuZmFsbGJhY2tBdHRyaWJ1dGUgOiB1bmRlZmluZWQpO1xuICAgIGNvbnN0IG1ldGEgPSBleHBlcmltZW50Lm1ldGEgPyBleHBlcmltZW50Lm1ldGFbdmFyaWF0aW9uSW5kZXhdIDoge307XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAga2V5OiBtZXRhLmtleSB8fCBcIlwiICsgdmFyaWF0aW9uSW5kZXgsXG4gICAgICBmZWF0dXJlSWQsXG4gICAgICBpbkV4cGVyaW1lbnQsXG4gICAgICBoYXNoVXNlZCxcbiAgICAgIHZhcmlhdGlvbklkOiB2YXJpYXRpb25JbmRleCxcbiAgICAgIHZhbHVlOiBleHBlcmltZW50LnZhcmlhdGlvbnNbdmFyaWF0aW9uSW5kZXhdLFxuICAgICAgaGFzaEF0dHJpYnV0ZSxcbiAgICAgIGhhc2hWYWx1ZSxcbiAgICAgIHN0aWNreUJ1Y2tldFVzZWQ6ICEhc3RpY2t5QnVja2V0VXNlZFxuICAgIH07XG4gICAgaWYgKG1ldGEubmFtZSkgcmVzLm5hbWUgPSBtZXRhLm5hbWU7XG4gICAgaWYgKGJ1Y2tldCAhPT0gdW5kZWZpbmVkKSByZXMuYnVja2V0ID0gYnVja2V0O1xuICAgIGlmIChtZXRhLnBhc3N0aHJvdWdoKSByZXMucGFzc3Rocm91Z2ggPSBtZXRhLnBhc3N0aHJvdWdoO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgX2dldENvbnRleHRVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N0eC51cmwgfHwgKGlzQnJvd3NlciA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogXCJcIik7XG4gIH1cbiAgX3VybElzVmFsaWQodXJsUmVnZXgpIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLl9nZXRDb250ZXh0VXJsKCk7XG4gICAgaWYgKCF1cmwpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwYXRoT25seSA9IHVybC5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcLy8sIFwiXCIpLnJlcGxhY2UoL15bXi9dKlxcLy8sIFwiL1wiKTtcbiAgICBpZiAodXJsUmVnZXgudGVzdCh1cmwpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodXJsUmVnZXgudGVzdChwYXRoT25seSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfaGFzR3JvdXBPdmVybGFwKGV4cEdyb3Vwcykge1xuICAgIGNvbnN0IGdyb3VwcyA9IHRoaXMuX2N0eC5ncm91cHMgfHwge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChncm91cHNbZXhwR3JvdXBzW2ldXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfYXBwbHlET01DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuO1xuICAgIGNvbnN0IHVuZG8gPSBbXTtcbiAgICBpZiAoY2hhbmdlcy5jc3MpIHtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzLmlubmVySFRNTCA9IGNoYW5nZXMuY3NzO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzKTtcbiAgICAgIHVuZG8ucHVzaCgoKSA9PiBzLnJlbW92ZSgpKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZXMuanMpIHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICBzY3JpcHQuaW5uZXJIVE1MID0gY2hhbmdlcy5qcztcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgIHVuZG8ucHVzaCgoKSA9PiBzY3JpcHQucmVtb3ZlKCkpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlcy5kb21NdXRhdGlvbnMpIHtcbiAgICAgIGNoYW5nZXMuZG9tTXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICB1bmRvLnB1c2gobXV0YXRlLmRlY2xhcmF0aXZlKG11dGF0aW9uKS5yZXZlcnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bmRvLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gICAgfTtcbiAgfVxuICBfZGVyaXZlU3RpY2t5QnVja2V0SWRlbnRpZmllckF0dHJpYnV0ZXMoZGF0YSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBkYXRhICYmIGRhdGEuZmVhdHVyZXMgPyBkYXRhLmZlYXR1cmVzIDogdGhpcy5nZXRGZWF0dXJlcygpO1xuICAgIGNvbnN0IGV4cGVyaW1lbnRzID0gZGF0YSAmJiBkYXRhLmV4cGVyaW1lbnRzID8gZGF0YS5leHBlcmltZW50cyA6IHRoaXMuZ2V0RXhwZXJpbWVudHMoKTtcbiAgICBPYmplY3Qua2V5cyhmZWF0dXJlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXNbaWRdO1xuICAgICAgaWYgKGZlYXR1cmUucnVsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGZlYXR1cmUucnVsZXMpIHtcbiAgICAgICAgICBpZiAocnVsZS52YXJpYXRpb25zKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmFkZChydWxlLmhhc2hBdHRyaWJ1dGUgfHwgXCJpZFwiKTtcbiAgICAgICAgICAgIGlmIChydWxlLmZhbGxiYWNrQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYWRkKHJ1bGUuZmFsbGJhY2tBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGV4cGVyaW1lbnRzLm1hcChleHBlcmltZW50ID0+IHtcbiAgICAgIGF0dHJpYnV0ZXMuYWRkKGV4cGVyaW1lbnQuaGFzaEF0dHJpYnV0ZSB8fCBcImlkXCIpO1xuICAgICAgaWYgKGV4cGVyaW1lbnQuZmFsbGJhY2tBdHRyaWJ1dGUpIHtcbiAgICAgICAgYXR0cmlidXRlcy5hZGQoZXhwZXJpbWVudC5mYWxsYmFja0F0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXR0cmlidXRlcyk7XG4gIH1cbiAgYXN5bmMgcmVmcmVzaFN0aWNreUJ1Y2tldHMoZGF0YSkge1xuICAgIGlmICh0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuX2dldFN0aWNreUJ1Y2tldEF0dHJpYnV0ZXMoZGF0YSk7XG4gICAgICB0aGlzLl9jdHguc3RpY2t5QnVja2V0QXNzaWdubWVudERvY3MgPSBhd2FpdCB0aGlzLl9jdHguc3RpY2t5QnVja2V0U2VydmljZS5nZXRBbGxBc3NpZ25tZW50cyhhdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cbiAgX2dldFN0aWNreUJ1Y2tldEFzc2lnbm1lbnRzKCkge1xuICAgIGNvbnN0IG1lcmdlZEFzc2lnbm1lbnRzID0ge307XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9jdHguc3RpY2t5QnVja2V0QXNzaWdubWVudERvY3MgfHwge30pLmZvckVhY2goZG9jID0+IHtcbiAgICAgIGlmIChkb2MuYXNzaWdubWVudHMpIE9iamVjdC5hc3NpZ24obWVyZ2VkQXNzaWdubWVudHMsIGRvYy5hc3NpZ25tZW50cyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZEFzc2lnbm1lbnRzO1xuICB9XG4gIF9nZXRTdGlja3lCdWNrZXRWYXJpYXRpb24oZXhwZXJpbWVudEtleSwgZXhwZXJpbWVudEJ1Y2tldFZlcnNpb24sIG1pbkV4cGVyaW1lbnRCdWNrZXRWZXJzaW9uLCBtZXRhKSB7XG4gICAgZXhwZXJpbWVudEJ1Y2tldFZlcnNpb24gPSBleHBlcmltZW50QnVja2V0VmVyc2lvbiB8fCAwO1xuICAgIG1pbkV4cGVyaW1lbnRCdWNrZXRWZXJzaW9uID0gbWluRXhwZXJpbWVudEJ1Y2tldFZlcnNpb24gfHwgMDtcbiAgICBtZXRhID0gbWV0YSB8fCBbXTtcbiAgICBjb25zdCBpZCA9IHRoaXMuX2dldFN0aWNreUJ1Y2tldEV4cGVyaW1lbnRLZXkoZXhwZXJpbWVudEtleSwgZXhwZXJpbWVudEJ1Y2tldFZlcnNpb24pO1xuICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gdGhpcy5fZ2V0U3RpY2t5QnVja2V0QXNzaWdubWVudHMoKTtcblxuICAgIC8vIHVzZXJzIHdpdGggYW55IGJsb2NrZWQgYnVja2V0IHZlcnNpb24gKDAgdG8gbWluRXhwZXJpbWVudEJ1Y2tldFZlcnNpb24pIGFyZSBleGNsdWRlZCBmcm9tIHRoZSB0ZXN0XG4gICAgaWYgKG1pbkV4cGVyaW1lbnRCdWNrZXRWZXJzaW9uID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWluRXhwZXJpbWVudEJ1Y2tldFZlcnNpb247IGkrKykge1xuICAgICAgICBjb25zdCBibG9ja2VkS2V5ID0gdGhpcy5fZ2V0U3RpY2t5QnVja2V0RXhwZXJpbWVudEtleShleHBlcmltZW50S2V5LCBpKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnRzW2Jsb2NrZWRLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFyaWF0aW9uOiAtMSxcbiAgICAgICAgICAgIHZlcnNpb25Jc0Jsb2NrZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhdGlvbktleSA9IGFzc2lnbm1lbnRzW2lkXTtcbiAgICBpZiAodmFyaWF0aW9uS2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAvLyBubyBhc3NpZ25tZW50IGZvdW5kXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YXJpYXRpb246IC0xXG4gICAgICB9O1xuICAgIGNvbnN0IHZhcmlhdGlvbiA9IG1ldGEuZmluZEluZGV4KG0gPT4gbS5rZXkgPT09IHZhcmlhdGlvbktleSk7XG4gICAgaWYgKHZhcmlhdGlvbiA8IDApXG4gICAgICAvLyBpbnZhbGlkIGFzc2lnbm1lbnQsIHRyZWF0IGFzIFwibm8gYXNzaWdubWVudCBmb3VuZFwiXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YXJpYXRpb246IC0xXG4gICAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB2YXJpYXRpb25cbiAgICB9O1xuICB9XG4gIF9nZXRTdGlja3lCdWNrZXRFeHBlcmltZW50S2V5KGV4cGVyaW1lbnRLZXksIGV4cGVyaW1lbnRCdWNrZXRWZXJzaW9uKSB7XG4gICAgZXhwZXJpbWVudEJ1Y2tldFZlcnNpb24gPSBleHBlcmltZW50QnVja2V0VmVyc2lvbiB8fCAwO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChleHBlcmltZW50S2V5LCBcIl9fXCIpLmNvbmNhdChleHBlcmltZW50QnVja2V0VmVyc2lvbik7XG4gIH1cbiAgX2dldFN0aWNreUJ1Y2tldEF0dHJpYnV0ZXMoZGF0YSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLl9jdHguc3RpY2t5QnVja2V0SWRlbnRpZmllckF0dHJpYnV0ZXMgPSAhdGhpcy5fY3R4LnN0aWNreUJ1Y2tldElkZW50aWZpZXJBdHRyaWJ1dGVzID8gdGhpcy5fZGVyaXZlU3RpY2t5QnVja2V0SWRlbnRpZmllckF0dHJpYnV0ZXMoZGF0YSkgOiB0aGlzLl9jdHguc3RpY2t5QnVja2V0SWRlbnRpZmllckF0dHJpYnV0ZXM7XG4gICAgdGhpcy5fY3R4LnN0aWNreUJ1Y2tldElkZW50aWZpZXJBdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhhc2hWYWx1ZVxuICAgICAgfSA9IHRoaXMuX2dldEhhc2hBdHRyaWJ1dGUoYXR0cik7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gdG9TdHJpbmcoaGFzaFZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuICBfZ2VuZXJhdGVTdGlja3lCdWNrZXRBc3NpZ25tZW50RG9jKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlLCBhc3NpZ25tZW50cykge1xuICAgIGNvbnN0IGtleSA9IFwiXCIuY29uY2F0KGF0dHJpYnV0ZU5hbWUsIFwifHxcIikuY29uY2F0KGF0dHJpYnV0ZVZhbHVlKTtcbiAgICBjb25zdCBleGlzdGluZ0Fzc2lnbm1lbnRzID0gdGhpcy5fY3R4LnN0aWNreUJ1Y2tldEFzc2lnbm1lbnREb2NzICYmIHRoaXMuX2N0eC5zdGlja3lCdWNrZXRBc3NpZ25tZW50RG9jc1trZXldID8gdGhpcy5fY3R4LnN0aWNreUJ1Y2tldEFzc2lnbm1lbnREb2NzW2tleV0uYXNzaWdubWVudHMgfHwge30gOiB7fTtcbiAgICBjb25zdCBuZXdBc3NpZ25tZW50cyA9IHtcbiAgICAgIC4uLmV4aXN0aW5nQXNzaWdubWVudHMsXG4gICAgICAuLi5hc3NpZ25tZW50c1xuICAgIH07XG4gICAgY29uc3QgY2hhbmdlZCA9IEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nQXNzaWdubWVudHMpICE9PSBKU09OLnN0cmluZ2lmeShuZXdBc3NpZ25tZW50cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIGRvYzoge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgYXNzaWdubWVudHM6IG5ld0Fzc2lnbm1lbnRzXG4gICAgICB9LFxuICAgICAgY2hhbmdlZFxuICAgIH07XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyb3d0aEJvb2suanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/GrowthBook.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/feature-repository.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/feature-repository.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearCache: () => (/* binding */ clearCache),\n/* harmony export */   configureCache: () => (/* binding */ configureCache),\n/* harmony export */   helpers: () => (/* binding */ helpers),\n/* harmony export */   onHidden: () => (/* binding */ onHidden),\n/* harmony export */   onVisible: () => (/* binding */ onVisible),\n/* harmony export */   refreshFeatures: () => (/* binding */ refreshFeatures),\n/* harmony export */   setPolyfills: () => (/* binding */ setPolyfills),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   unsubscribe: () => (/* binding */ unsubscribe)\n/* harmony export */ });\n// Config settings\nconst cacheSettings = {\n  // Consider a fetch stale after 1 minute\n  staleTTL: 1000 * 60,\n  cacheKey: \"gbFeaturesCache\",\n  backgroundSync: true,\n  maxEntries: 10,\n  disableIdleStreams: false,\n  idleStreamInterval: 20000\n};\nconst polyfills = {\n  fetch: globalThis.fetch ? globalThis.fetch.bind(globalThis) : undefined,\n  SubtleCrypto: globalThis.crypto ? globalThis.crypto.subtle : undefined,\n  EventSource: globalThis.EventSource\n};\nconst helpers = {\n  fetchFeaturesCall: _ref => {\n    let {\n      host,\n      clientKey,\n      headers\n    } = _ref;\n    return polyfills.fetch(\"\".concat(host, \"/api/features/\").concat(clientKey), {\n      headers\n    });\n  },\n  fetchRemoteEvalCall: _ref2 => {\n    let {\n      host,\n      clientKey,\n      payload,\n      headers\n    } = _ref2;\n    const options = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body: JSON.stringify(payload)\n    };\n    return polyfills.fetch(\"\".concat(host, \"/api/eval/\").concat(clientKey), options);\n  },\n  eventSourceCall: _ref3 => {\n    let {\n      host,\n      clientKey,\n      headers\n    } = _ref3;\n    if (headers) {\n      return new polyfills.EventSource(\"\".concat(host, \"/sub/\").concat(clientKey), {\n        headers\n      });\n    }\n    return new polyfills.EventSource(\"\".concat(host, \"/sub/\").concat(clientKey));\n  },\n  startIdleListener: () => {\n    let idleTimeout;\n    const isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n    if (!isBrowser) return;\n    const onVisibilityChange = () => {\n      if (document.visibilityState === \"visible\") {\n        window.clearTimeout(idleTimeout);\n        onVisible();\n      } else if (document.visibilityState === \"hidden\") {\n        idleTimeout = window.setTimeout(onHidden, cacheSettings.idleStreamInterval);\n      }\n    };\n    document.addEventListener(\"visibilitychange\", onVisibilityChange);\n    return () => document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  },\n  stopIdleListener: () => {\n    // No-op, replaced by startIdleListener\n  }\n};\ntry {\n  if (globalThis.localStorage) {\n    polyfills.localStorage = globalThis.localStorage;\n  }\n} catch (e) {\n  // Ignore localStorage errors\n}\n\n// Global state\nconst subscribedInstances = new Map();\nlet cacheInitialized = false;\nconst cache = new Map();\nconst activeFetches = new Map();\nconst streams = new Map();\nconst supportsSSE = new Set();\n\n// Public functions\nfunction setPolyfills(overrides) {\n  Object.assign(polyfills, overrides);\n}\nfunction configureCache(overrides) {\n  Object.assign(cacheSettings, overrides);\n  if (!cacheSettings.backgroundSync) {\n    clearAutoRefresh();\n  }\n}\nasync function clearCache() {\n  cache.clear();\n  activeFetches.clear();\n  clearAutoRefresh();\n  cacheInitialized = false;\n  await updatePersistentCache();\n}\nasync function refreshFeatures(instance, timeout, skipCache, allowStale, updateInstance, backgroundSync) {\n  if (!backgroundSync) {\n    cacheSettings.backgroundSync = false;\n  }\n  const data = await fetchFeaturesWithCache(instance, allowStale, timeout, skipCache);\n  updateInstance && data && (await refreshInstance(instance, data));\n}\n\n// Subscribe a GrowthBook instance to feature changes\nfunction subscribe(instance) {\n  const key = getKey(instance);\n  const subs = subscribedInstances.get(key) || new Set();\n  subs.add(instance);\n  subscribedInstances.set(key, subs);\n}\nfunction unsubscribe(instance) {\n  subscribedInstances.forEach(s => s.delete(instance));\n}\nfunction onHidden() {\n  streams.forEach(channel => {\n    if (!channel) return;\n    channel.state = \"idle\";\n    disableChannel(channel);\n  });\n}\nfunction onVisible() {\n  streams.forEach(channel => {\n    if (!channel) return;\n    if (channel.state !== \"idle\") return;\n    enableChannel(channel);\n  });\n}\n\n// Private functions\n\nasync function updatePersistentCache() {\n  try {\n    if (!polyfills.localStorage) return;\n    await polyfills.localStorage.setItem(cacheSettings.cacheKey, JSON.stringify(Array.from(cache.entries())));\n  } catch (e) {\n    // Ignore localStorage errors\n  }\n}\nasync function fetchFeaturesWithCache(instance, allowStale, timeout, skipCache) {\n  const key = getKey(instance);\n  const cacheKey = getCacheKey(instance);\n  const now = new Date();\n  await initializeCache();\n  const existing = cache.get(cacheKey);\n  if (existing && !skipCache && (allowStale || existing.staleAt > now)) {\n    // Restore from cache whether SSE is supported\n    if (existing.sse) supportsSSE.add(key);\n\n    // Reload features in the background if stale\n    if (existing.staleAt < now) {\n      fetchFeatures(instance);\n    }\n    // Otherwise, if we don't need to refresh now, start a background sync\n    else {\n      startAutoRefresh(instance);\n    }\n    return existing.data;\n  } else {\n    return await promiseTimeout(fetchFeatures(instance), timeout);\n  }\n}\nfunction getKey(instance) {\n  const [apiHost, clientKey] = instance.getApiInfo();\n  return \"\".concat(apiHost, \"||\").concat(clientKey);\n}\nfunction getCacheKey(instance) {\n  const baseKey = getKey(instance);\n  if (!instance.isRemoteEval()) return baseKey;\n  const attributes = instance.getAttributes();\n  const cacheKeyAttributes = instance.getCacheKeyAttributes() || Object.keys(instance.getAttributes());\n  const ca = {};\n  cacheKeyAttributes.forEach(key => {\n    ca[key] = attributes[key];\n  });\n  const fv = instance.getForcedVariations();\n  const url = instance.getUrl();\n  return \"\".concat(baseKey, \"||\").concat(JSON.stringify({\n    ca,\n    fv,\n    url\n  }));\n}\n\n// Guarantee the promise always resolves within {timeout} ms\n// Resolved value will be `null` when there's an error or it takes too long\n// Note: The promise will continue running in the background, even if the timeout is hit\nfunction promiseTimeout(promise, timeout) {\n  return new Promise(resolve => {\n    let resolved = false;\n    let timer;\n    const finish = data => {\n      if (resolved) return;\n      resolved = true;\n      timer && clearTimeout(timer);\n      resolve(data || null);\n    };\n    if (timeout) {\n      timer = setTimeout(() => finish(), timeout);\n    }\n    promise.then(data => finish(data)).catch(() => finish());\n  });\n}\n\n// Populate cache from localStorage (if available)\nasync function initializeCache() {\n  if (cacheInitialized) return;\n  cacheInitialized = true;\n  try {\n    if (polyfills.localStorage) {\n      const value = await polyfills.localStorage.getItem(cacheSettings.cacheKey);\n      if (value) {\n        const parsed = JSON.parse(value);\n        if (parsed && Array.isArray(parsed)) {\n          parsed.forEach(_ref4 => {\n            let [key, data] = _ref4;\n            cache.set(key, {\n              ...data,\n              staleAt: new Date(data.staleAt)\n            });\n          });\n        }\n        cleanupCache();\n      }\n    }\n  } catch (e) {\n    // Ignore localStorage errors\n  }\n  if (!cacheSettings.disableIdleStreams) {\n    const cleanupFn = helpers.startIdleListener();\n    if (cleanupFn) {\n      helpers.stopIdleListener = cleanupFn;\n    }\n  }\n}\n\n// Enforce the maxEntries limit\nfunction cleanupCache() {\n  const entriesWithTimestamps = Array.from(cache.entries()).map(_ref5 => {\n    let [key, value] = _ref5;\n    return {\n      key,\n      staleAt: value.staleAt.getTime()\n    };\n  }).sort((a, b) => a.staleAt - b.staleAt);\n  const entriesToRemoveCount = Math.min(Math.max(0, cache.size - cacheSettings.maxEntries), cache.size);\n  for (let i = 0; i < entriesToRemoveCount; i++) {\n    cache.delete(entriesWithTimestamps[i].key);\n  }\n}\n\n// Called whenever new features are fetched from the API\nfunction onNewFeatureData(key, cacheKey, data) {\n  // If contents haven't changed, ignore the update, extend the stale TTL\n  const version = data.dateUpdated || \"\";\n  const staleAt = new Date(Date.now() + cacheSettings.staleTTL);\n  const existing = cache.get(cacheKey);\n  if (existing && version && existing.version === version) {\n    existing.staleAt = staleAt;\n    updatePersistentCache();\n    return;\n  }\n\n  // Update in-memory cache\n  cache.set(cacheKey, {\n    data,\n    version,\n    staleAt,\n    sse: supportsSSE.has(key)\n  });\n  cleanupCache();\n  // Update local storage (don't await this, just update asynchronously)\n  updatePersistentCache();\n\n  // Update features for all subscribed GrowthBook instances\n  const instances = subscribedInstances.get(key);\n  instances && instances.forEach(instance => refreshInstance(instance, data));\n}\nasync function refreshInstance(instance, data) {\n  data = await instance.decryptPayload(data, undefined, polyfills.SubtleCrypto);\n  await instance.refreshStickyBuckets(data);\n  instance.setExperiments(data.experiments || instance.getExperiments());\n  instance.setFeatures(data.features || instance.getFeatures());\n}\nasync function fetchFeatures(instance) {\n  const {\n    apiHost,\n    apiRequestHeaders\n  } = instance.getApiHosts();\n  const clientKey = instance.getClientKey();\n  const remoteEval = instance.isRemoteEval();\n  const key = getKey(instance);\n  const cacheKey = getCacheKey(instance);\n  let promise = activeFetches.get(cacheKey);\n  if (!promise) {\n    const fetcher = remoteEval ? helpers.fetchRemoteEvalCall({\n      host: apiHost,\n      clientKey,\n      payload: {\n        attributes: instance.getAttributes(),\n        forcedVariations: instance.getForcedVariations(),\n        forcedFeatures: Array.from(instance.getForcedFeatures().entries()),\n        url: instance.getUrl()\n      },\n      headers: apiRequestHeaders\n    }) : helpers.fetchFeaturesCall({\n      host: apiHost,\n      clientKey,\n      headers: apiRequestHeaders\n    });\n\n    // TODO: auto-retry if status code indicates a temporary error\n    promise = fetcher.then(res => {\n      if (res.headers.get(\"x-sse-support\") === \"enabled\") {\n        supportsSSE.add(key);\n      }\n      return res.json();\n    }).then(data => {\n      onNewFeatureData(key, cacheKey, data);\n      startAutoRefresh(instance);\n      activeFetches.delete(cacheKey);\n      return data;\n    }).catch(e => {\n       true && instance.log(\"Error fetching features\", {\n        apiHost,\n        clientKey,\n        error: e ? e.message : null\n      });\n      activeFetches.delete(cacheKey);\n      return Promise.resolve({});\n    });\n    activeFetches.set(cacheKey, promise);\n  }\n  return await promise;\n}\n\n// Watch a feature endpoint for changes\n// Will prefer SSE if enabled, otherwise fall back to cron\nfunction startAutoRefresh(instance) {\n  const key = getKey(instance);\n  const cacheKey = getCacheKey(instance);\n  const {\n    streamingHost,\n    streamingHostRequestHeaders\n  } = instance.getApiHosts();\n  const clientKey = instance.getClientKey();\n  if (cacheSettings.backgroundSync && supportsSSE.has(key) && polyfills.EventSource) {\n    if (streams.has(key)) return;\n    const channel = {\n      src: null,\n      host: streamingHost,\n      clientKey,\n      headers: streamingHostRequestHeaders,\n      cb: event => {\n        try {\n          if (event.type === \"features-updated\") {\n            const instances = subscribedInstances.get(key);\n            instances && instances.forEach(instance => {\n              fetchFeatures(instance);\n            });\n          } else if (event.type === \"features\") {\n            const json = JSON.parse(event.data);\n            onNewFeatureData(key, cacheKey, json);\n          }\n          // Reset error count on success\n          channel.errors = 0;\n        } catch (e) {\n           true && instance.log(\"SSE Error\", {\n            streamingHost,\n            clientKey,\n            error: e ? e.message : null\n          });\n          onSSEError(channel);\n        }\n      },\n      errors: 0,\n      state: \"active\"\n    };\n    streams.set(key, channel);\n    enableChannel(channel);\n  }\n}\nfunction onSSEError(channel) {\n  if (channel.state === \"idle\") return;\n  channel.errors++;\n  if (channel.errors > 3 || channel.src && channel.src.readyState === 2) {\n    // exponential backoff after 4 errors, with jitter\n    const delay = Math.pow(3, channel.errors - 3) * (1000 + Math.random() * 1000);\n    disableChannel(channel);\n    setTimeout(() => {\n      if ([\"idle\", \"active\"].includes(channel.state)) return;\n      enableChannel(channel);\n    }, Math.min(delay, 300000)); // 5 minutes max\n  }\n}\n\nfunction disableChannel(channel) {\n  if (!channel.src) return;\n  channel.src.onopen = null;\n  channel.src.onerror = null;\n  channel.src.close();\n  channel.src = null;\n  if (channel.state === \"active\") {\n    channel.state = \"disabled\";\n  }\n}\nfunction enableChannel(channel) {\n  channel.src = helpers.eventSourceCall({\n    host: channel.host,\n    clientKey: channel.clientKey,\n    headers: channel.headers\n  });\n  channel.state = \"active\";\n  channel.src.addEventListener(\"features\", channel.cb);\n  channel.src.addEventListener(\"features-updated\", channel.cb);\n  channel.src.onerror = () => onSSEError(channel);\n  channel.src.onopen = () => {\n    channel.errors = 0;\n  };\n}\nfunction destroyChannel(channel, key) {\n  disableChannel(channel);\n  streams.delete(key);\n}\nfunction clearAutoRefresh() {\n  // Clear list of which keys are auto-updated\n  supportsSSE.clear();\n\n  // Stop listening for any SSE events\n  streams.forEach(destroyChannel);\n\n  // Remove all references to GrowthBook instances\n  subscribedInstances.clear();\n\n  // Run the idle stream cleanup function\n  helpers.stopIdleListener();\n}\n//# sourceMappingURL=feature-repository.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bncm93dGhib29rK2dyb3d0aGJvb2tAMC4zMi4wL25vZGVfbW9kdWxlcy9AZ3Jvd3RoYm9vay9ncm93dGhib29rL2Rpc3QvZXNtL2ZlYXR1cmUtcmVwb3NpdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwrQkFBK0I7QUFDL0IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRCQUE0QjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZ3Jvd3RoYm9vaytncm93dGhib29rQDAuMzIuMC9ub2RlX21vZHVsZXMvQGdyb3d0aGJvb2svZ3Jvd3RoYm9vay9kaXN0L2VzbS9mZWF0dXJlLXJlcG9zaXRvcnkuanM/MDBjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb25maWcgc2V0dGluZ3NcbmNvbnN0IGNhY2hlU2V0dGluZ3MgPSB7XG4gIC8vIENvbnNpZGVyIGEgZmV0Y2ggc3RhbGUgYWZ0ZXIgMSBtaW51dGVcbiAgc3RhbGVUVEw6IDEwMDAgKiA2MCxcbiAgY2FjaGVLZXk6IFwiZ2JGZWF0dXJlc0NhY2hlXCIsXG4gIGJhY2tncm91bmRTeW5jOiB0cnVlLFxuICBtYXhFbnRyaWVzOiAxMCxcbiAgZGlzYWJsZUlkbGVTdHJlYW1zOiBmYWxzZSxcbiAgaWRsZVN0cmVhbUludGVydmFsOiAyMDAwMFxufTtcbmNvbnN0IHBvbHlmaWxscyA9IHtcbiAgZmV0Y2g6IGdsb2JhbFRoaXMuZmV0Y2ggPyBnbG9iYWxUaGlzLmZldGNoLmJpbmQoZ2xvYmFsVGhpcykgOiB1bmRlZmluZWQsXG4gIFN1YnRsZUNyeXB0bzogZ2xvYmFsVGhpcy5jcnlwdG8gPyBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUgOiB1bmRlZmluZWQsXG4gIEV2ZW50U291cmNlOiBnbG9iYWxUaGlzLkV2ZW50U291cmNlXG59O1xuZXhwb3J0IGNvbnN0IGhlbHBlcnMgPSB7XG4gIGZldGNoRmVhdHVyZXNDYWxsOiBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgaG9zdCxcbiAgICAgIGNsaWVudEtleSxcbiAgICAgIGhlYWRlcnNcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gcG9seWZpbGxzLmZldGNoKFwiXCIuY29uY2F0KGhvc3QsIFwiL2FwaS9mZWF0dXJlcy9cIikuY29uY2F0KGNsaWVudEtleSksIHtcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgfSxcbiAgZmV0Y2hSZW1vdGVFdmFsQ2FsbDogX3JlZjIgPT4ge1xuICAgIGxldCB7XG4gICAgICBob3N0LFxuICAgICAgY2xpZW50S2V5LFxuICAgICAgcGF5bG9hZCxcbiAgICAgIGhlYWRlcnNcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcbiAgICB9O1xuICAgIHJldHVybiBwb2x5ZmlsbHMuZmV0Y2goXCJcIi5jb25jYXQoaG9zdCwgXCIvYXBpL2V2YWwvXCIpLmNvbmNhdChjbGllbnRLZXkpLCBvcHRpb25zKTtcbiAgfSxcbiAgZXZlbnRTb3VyY2VDYWxsOiBfcmVmMyA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGhvc3QsXG4gICAgICBjbGllbnRLZXksXG4gICAgICBoZWFkZXJzXG4gICAgfSA9IF9yZWYzO1xuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICByZXR1cm4gbmV3IHBvbHlmaWxscy5FdmVudFNvdXJjZShcIlwiLmNvbmNhdChob3N0LCBcIi9zdWIvXCIpLmNvbmNhdChjbGllbnRLZXkpLCB7XG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHBvbHlmaWxscy5FdmVudFNvdXJjZShcIlwiLmNvbmNhdChob3N0LCBcIi9zdWIvXCIpLmNvbmNhdChjbGllbnRLZXkpKTtcbiAgfSxcbiAgc3RhcnRJZGxlTGlzdGVuZXI6ICgpID0+IHtcbiAgICBsZXQgaWRsZVRpbWVvdXQ7XG4gICAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybjtcbiAgICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkbGVUaW1lb3V0KTtcbiAgICAgICAgb25WaXNpYmxlKCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICBpZGxlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KG9uSGlkZGVuLCBjYWNoZVNldHRpbmdzLmlkbGVTdHJlYW1JbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB9LFxuICBzdG9wSWRsZUxpc3RlbmVyOiAoKSA9PiB7XG4gICAgLy8gTm8tb3AsIHJlcGxhY2VkIGJ5IHN0YXJ0SWRsZUxpc3RlbmVyXG4gIH1cbn07XG50cnkge1xuICBpZiAoZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UpIHtcbiAgICBwb2x5ZmlsbHMubG9jYWxTdG9yYWdlID0gZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2U7XG4gIH1cbn0gY2F0Y2ggKGUpIHtcbiAgLy8gSWdub3JlIGxvY2FsU3RvcmFnZSBlcnJvcnNcbn1cblxuLy8gR2xvYmFsIHN0YXRlXG5jb25zdCBzdWJzY3JpYmVkSW5zdGFuY2VzID0gbmV3IE1hcCgpO1xubGV0IGNhY2hlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3QgYWN0aXZlRmV0Y2hlcyA9IG5ldyBNYXAoKTtcbmNvbnN0IHN0cmVhbXMgPSBuZXcgTWFwKCk7XG5jb25zdCBzdXBwb3J0c1NTRSA9IG5ldyBTZXQoKTtcblxuLy8gUHVibGljIGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHNldFBvbHlmaWxscyhvdmVycmlkZXMpIHtcbiAgT2JqZWN0LmFzc2lnbihwb2x5ZmlsbHMsIG92ZXJyaWRlcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlQ2FjaGUob3ZlcnJpZGVzKSB7XG4gIE9iamVjdC5hc3NpZ24oY2FjaGVTZXR0aW5ncywgb3ZlcnJpZGVzKTtcbiAgaWYgKCFjYWNoZVNldHRpbmdzLmJhY2tncm91bmRTeW5jKSB7XG4gICAgY2xlYXJBdXRvUmVmcmVzaCgpO1xuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgY2FjaGUuY2xlYXIoKTtcbiAgYWN0aXZlRmV0Y2hlcy5jbGVhcigpO1xuICBjbGVhckF1dG9SZWZyZXNoKCk7XG4gIGNhY2hlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgYXdhaXQgdXBkYXRlUGVyc2lzdGVudENhY2hlKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEZlYXR1cmVzKGluc3RhbmNlLCB0aW1lb3V0LCBza2lwQ2FjaGUsIGFsbG93U3RhbGUsIHVwZGF0ZUluc3RhbmNlLCBiYWNrZ3JvdW5kU3luYykge1xuICBpZiAoIWJhY2tncm91bmRTeW5jKSB7XG4gICAgY2FjaGVTZXR0aW5ncy5iYWNrZ3JvdW5kU3luYyA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaEZlYXR1cmVzV2l0aENhY2hlKGluc3RhbmNlLCBhbGxvd1N0YWxlLCB0aW1lb3V0LCBza2lwQ2FjaGUpO1xuICB1cGRhdGVJbnN0YW5jZSAmJiBkYXRhICYmIChhd2FpdCByZWZyZXNoSW5zdGFuY2UoaW5zdGFuY2UsIGRhdGEpKTtcbn1cblxuLy8gU3Vic2NyaWJlIGEgR3Jvd3RoQm9vayBpbnN0YW5jZSB0byBmZWF0dXJlIGNoYW5nZXNcbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmUoaW5zdGFuY2UpIHtcbiAgY29uc3Qga2V5ID0gZ2V0S2V5KGluc3RhbmNlKTtcbiAgY29uc3Qgc3VicyA9IHN1YnNjcmliZWRJbnN0YW5jZXMuZ2V0KGtleSkgfHwgbmV3IFNldCgpO1xuICBzdWJzLmFkZChpbnN0YW5jZSk7XG4gIHN1YnNjcmliZWRJbnN0YW5jZXMuc2V0KGtleSwgc3Vicyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5zdWJzY3JpYmUoaW5zdGFuY2UpIHtcbiAgc3Vic2NyaWJlZEluc3RhbmNlcy5mb3JFYWNoKHMgPT4gcy5kZWxldGUoaW5zdGFuY2UpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvbkhpZGRlbigpIHtcbiAgc3RyZWFtcy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgIGlmICghY2hhbm5lbCkgcmV0dXJuO1xuICAgIGNoYW5uZWwuc3RhdGUgPSBcImlkbGVcIjtcbiAgICBkaXNhYmxlQ2hhbm5lbChjaGFubmVsKTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gb25WaXNpYmxlKCkge1xuICBzdHJlYW1zLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgaWYgKCFjaGFubmVsKSByZXR1cm47XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgIT09IFwiaWRsZVwiKSByZXR1cm47XG4gICAgZW5hYmxlQ2hhbm5lbChjaGFubmVsKTtcbiAgfSk7XG59XG5cbi8vIFByaXZhdGUgZnVuY3Rpb25zXG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBlcnNpc3RlbnRDYWNoZSgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIXBvbHlmaWxscy5sb2NhbFN0b3JhZ2UpIHJldHVybjtcbiAgICBhd2FpdCBwb2x5ZmlsbHMubG9jYWxTdG9yYWdlLnNldEl0ZW0oY2FjaGVTZXR0aW5ncy5jYWNoZUtleSwgSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShjYWNoZS5lbnRyaWVzKCkpKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUgbG9jYWxTdG9yYWdlIGVycm9yc1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEZlYXR1cmVzV2l0aENhY2hlKGluc3RhbmNlLCBhbGxvd1N0YWxlLCB0aW1lb3V0LCBza2lwQ2FjaGUpIHtcbiAgY29uc3Qga2V5ID0gZ2V0S2V5KGluc3RhbmNlKTtcbiAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnN0YW5jZSk7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGF3YWl0IGluaXRpYWxpemVDYWNoZSgpO1xuICBjb25zdCBleGlzdGluZyA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChleGlzdGluZyAmJiAhc2tpcENhY2hlICYmIChhbGxvd1N0YWxlIHx8IGV4aXN0aW5nLnN0YWxlQXQgPiBub3cpKSB7XG4gICAgLy8gUmVzdG9yZSBmcm9tIGNhY2hlIHdoZXRoZXIgU1NFIGlzIHN1cHBvcnRlZFxuICAgIGlmIChleGlzdGluZy5zc2UpIHN1cHBvcnRzU1NFLmFkZChrZXkpO1xuXG4gICAgLy8gUmVsb2FkIGZlYXR1cmVzIGluIHRoZSBiYWNrZ3JvdW5kIGlmIHN0YWxlXG4gICAgaWYgKGV4aXN0aW5nLnN0YWxlQXQgPCBub3cpIHtcbiAgICAgIGZldGNoRmVhdHVyZXMoaW5zdGFuY2UpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlIGRvbid0IG5lZWQgdG8gcmVmcmVzaCBub3csIHN0YXJ0IGEgYmFja2dyb3VuZCBzeW5jXG4gICAgZWxzZSB7XG4gICAgICBzdGFydEF1dG9SZWZyZXNoKGluc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nLmRhdGE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2VUaW1lb3V0KGZldGNoRmVhdHVyZXMoaW5zdGFuY2UpLCB0aW1lb3V0KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5KGluc3RhbmNlKSB7XG4gIGNvbnN0IFthcGlIb3N0LCBjbGllbnRLZXldID0gaW5zdGFuY2UuZ2V0QXBpSW5mbygpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoYXBpSG9zdCwgXCJ8fFwiKS5jb25jYXQoY2xpZW50S2V5KTtcbn1cbmZ1bmN0aW9uIGdldENhY2hlS2V5KGluc3RhbmNlKSB7XG4gIGNvbnN0IGJhc2VLZXkgPSBnZXRLZXkoaW5zdGFuY2UpO1xuICBpZiAoIWluc3RhbmNlLmlzUmVtb3RlRXZhbCgpKSByZXR1cm4gYmFzZUtleTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZXMoKTtcbiAgY29uc3QgY2FjaGVLZXlBdHRyaWJ1dGVzID0gaW5zdGFuY2UuZ2V0Q2FjaGVLZXlBdHRyaWJ1dGVzKCkgfHwgT2JqZWN0LmtleXMoaW5zdGFuY2UuZ2V0QXR0cmlidXRlcygpKTtcbiAgY29uc3QgY2EgPSB7fTtcbiAgY2FjaGVLZXlBdHRyaWJ1dGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICBjYVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICB9KTtcbiAgY29uc3QgZnYgPSBpbnN0YW5jZS5nZXRGb3JjZWRWYXJpYXRpb25zKCk7XG4gIGNvbnN0IHVybCA9IGluc3RhbmNlLmdldFVybCgpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoYmFzZUtleSwgXCJ8fFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoe1xuICAgIGNhLFxuICAgIGZ2LFxuICAgIHVybFxuICB9KSk7XG59XG5cbi8vIEd1YXJhbnRlZSB0aGUgcHJvbWlzZSBhbHdheXMgcmVzb2x2ZXMgd2l0aGluIHt0aW1lb3V0fSBtc1xuLy8gUmVzb2x2ZWQgdmFsdWUgd2lsbCBiZSBgbnVsbGAgd2hlbiB0aGVyZSdzIGFuIGVycm9yIG9yIGl0IHRha2VzIHRvbyBsb25nXG4vLyBOb3RlOiBUaGUgcHJvbWlzZSB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgaW4gdGhlIGJhY2tncm91bmQsIGV2ZW4gaWYgdGhlIHRpbWVvdXQgaXMgaGl0XG5mdW5jdGlvbiBwcm9taXNlVGltZW91dChwcm9taXNlLCB0aW1lb3V0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICBsZXQgdGltZXI7XG4gICAgY29uc3QgZmluaXNoID0gZGF0YSA9PiB7XG4gICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICByZXNvbHZlKGRhdGEgfHwgbnVsbCk7XG4gICAgfTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGZpbmlzaCgpLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKGRhdGEgPT4gZmluaXNoKGRhdGEpKS5jYXRjaCgoKSA9PiBmaW5pc2goKSk7XG4gIH0pO1xufVxuXG4vLyBQb3B1bGF0ZSBjYWNoZSBmcm9tIGxvY2FsU3RvcmFnZSAoaWYgYXZhaWxhYmxlKVxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUNhY2hlKCkge1xuICBpZiAoY2FjaGVJbml0aWFsaXplZCkgcmV0dXJuO1xuICBjYWNoZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBpZiAocG9seWZpbGxzLmxvY2FsU3RvcmFnZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwb2x5ZmlsbHMubG9jYWxTdG9yYWdlLmdldEl0ZW0oY2FjaGVTZXR0aW5ncy5jYWNoZUtleSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGlmIChwYXJzZWQgJiYgQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG4gICAgICAgICAgcGFyc2VkLmZvckVhY2goX3JlZjQgPT4ge1xuICAgICAgICAgICAgbGV0IFtrZXksIGRhdGFdID0gX3JlZjQ7XG4gICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgIHN0YWxlQXQ6IG5ldyBEYXRlKGRhdGEuc3RhbGVBdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFudXBDYWNoZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZSBsb2NhbFN0b3JhZ2UgZXJyb3JzXG4gIH1cbiAgaWYgKCFjYWNoZVNldHRpbmdzLmRpc2FibGVJZGxlU3RyZWFtcykge1xuICAgIGNvbnN0IGNsZWFudXBGbiA9IGhlbHBlcnMuc3RhcnRJZGxlTGlzdGVuZXIoKTtcbiAgICBpZiAoY2xlYW51cEZuKSB7XG4gICAgICBoZWxwZXJzLnN0b3BJZGxlTGlzdGVuZXIgPSBjbGVhbnVwRm47XG4gICAgfVxuICB9XG59XG5cbi8vIEVuZm9yY2UgdGhlIG1heEVudHJpZXMgbGltaXRcbmZ1bmN0aW9uIGNsZWFudXBDYWNoZSgpIHtcbiAgY29uc3QgZW50cmllc1dpdGhUaW1lc3RhbXBzID0gQXJyYXkuZnJvbShjYWNoZS5lbnRyaWVzKCkpLm1hcChfcmVmNSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY1O1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBzdGFsZUF0OiB2YWx1ZS5zdGFsZUF0LmdldFRpbWUoKVxuICAgIH07XG4gIH0pLnNvcnQoKGEsIGIpID0+IGEuc3RhbGVBdCAtIGIuc3RhbGVBdCk7XG4gIGNvbnN0IGVudHJpZXNUb1JlbW92ZUNvdW50ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY2FjaGUuc2l6ZSAtIGNhY2hlU2V0dGluZ3MubWF4RW50cmllcyksIGNhY2hlLnNpemUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXNUb1JlbW92ZUNvdW50OyBpKyspIHtcbiAgICBjYWNoZS5kZWxldGUoZW50cmllc1dpdGhUaW1lc3RhbXBzW2ldLmtleSk7XG4gIH1cbn1cblxuLy8gQ2FsbGVkIHdoZW5ldmVyIG5ldyBmZWF0dXJlcyBhcmUgZmV0Y2hlZCBmcm9tIHRoZSBBUElcbmZ1bmN0aW9uIG9uTmV3RmVhdHVyZURhdGEoa2V5LCBjYWNoZUtleSwgZGF0YSkge1xuICAvLyBJZiBjb250ZW50cyBoYXZlbid0IGNoYW5nZWQsIGlnbm9yZSB0aGUgdXBkYXRlLCBleHRlbmQgdGhlIHN0YWxlIFRUTFxuICBjb25zdCB2ZXJzaW9uID0gZGF0YS5kYXRlVXBkYXRlZCB8fCBcIlwiO1xuICBjb25zdCBzdGFsZUF0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIGNhY2hlU2V0dGluZ3Muc3RhbGVUVEwpO1xuICBjb25zdCBleGlzdGluZyA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChleGlzdGluZyAmJiB2ZXJzaW9uICYmIGV4aXN0aW5nLnZlcnNpb24gPT09IHZlcnNpb24pIHtcbiAgICBleGlzdGluZy5zdGFsZUF0ID0gc3RhbGVBdDtcbiAgICB1cGRhdGVQZXJzaXN0ZW50Q2FjaGUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBVcGRhdGUgaW4tbWVtb3J5IGNhY2hlXG4gIGNhY2hlLnNldChjYWNoZUtleSwge1xuICAgIGRhdGEsXG4gICAgdmVyc2lvbixcbiAgICBzdGFsZUF0LFxuICAgIHNzZTogc3VwcG9ydHNTU0UuaGFzKGtleSlcbiAgfSk7XG4gIGNsZWFudXBDYWNoZSgpO1xuICAvLyBVcGRhdGUgbG9jYWwgc3RvcmFnZSAoZG9uJ3QgYXdhaXQgdGhpcywganVzdCB1cGRhdGUgYXN5bmNocm9ub3VzbHkpXG4gIHVwZGF0ZVBlcnNpc3RlbnRDYWNoZSgpO1xuXG4gIC8vIFVwZGF0ZSBmZWF0dXJlcyBmb3IgYWxsIHN1YnNjcmliZWQgR3Jvd3RoQm9vayBpbnN0YW5jZXNcbiAgY29uc3QgaW5zdGFuY2VzID0gc3Vic2NyaWJlZEluc3RhbmNlcy5nZXQoa2V5KTtcbiAgaW5zdGFuY2VzICYmIGluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHJlZnJlc2hJbnN0YW5jZShpbnN0YW5jZSwgZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluc3RhbmNlKGluc3RhbmNlLCBkYXRhKSB7XG4gIGRhdGEgPSBhd2FpdCBpbnN0YW5jZS5kZWNyeXB0UGF5bG9hZChkYXRhLCB1bmRlZmluZWQsIHBvbHlmaWxscy5TdWJ0bGVDcnlwdG8pO1xuICBhd2FpdCBpbnN0YW5jZS5yZWZyZXNoU3RpY2t5QnVja2V0cyhkYXRhKTtcbiAgaW5zdGFuY2Uuc2V0RXhwZXJpbWVudHMoZGF0YS5leHBlcmltZW50cyB8fCBpbnN0YW5jZS5nZXRFeHBlcmltZW50cygpKTtcbiAgaW5zdGFuY2Uuc2V0RmVhdHVyZXMoZGF0YS5mZWF0dXJlcyB8fCBpbnN0YW5jZS5nZXRGZWF0dXJlcygpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRmVhdHVyZXMoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIGFwaUhvc3QsXG4gICAgYXBpUmVxdWVzdEhlYWRlcnNcbiAgfSA9IGluc3RhbmNlLmdldEFwaUhvc3RzKCk7XG4gIGNvbnN0IGNsaWVudEtleSA9IGluc3RhbmNlLmdldENsaWVudEtleSgpO1xuICBjb25zdCByZW1vdGVFdmFsID0gaW5zdGFuY2UuaXNSZW1vdGVFdmFsKCk7XG4gIGNvbnN0IGtleSA9IGdldEtleShpbnN0YW5jZSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5zdGFuY2UpO1xuICBsZXQgcHJvbWlzZSA9IGFjdGl2ZUZldGNoZXMuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFwcm9taXNlKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IHJlbW90ZUV2YWwgPyBoZWxwZXJzLmZldGNoUmVtb3RlRXZhbENhbGwoe1xuICAgICAgaG9zdDogYXBpSG9zdCxcbiAgICAgIGNsaWVudEtleSxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgYXR0cmlidXRlczogaW5zdGFuY2UuZ2V0QXR0cmlidXRlcygpLFxuICAgICAgICBmb3JjZWRWYXJpYXRpb25zOiBpbnN0YW5jZS5nZXRGb3JjZWRWYXJpYXRpb25zKCksXG4gICAgICAgIGZvcmNlZEZlYXR1cmVzOiBBcnJheS5mcm9tKGluc3RhbmNlLmdldEZvcmNlZEZlYXR1cmVzKCkuZW50cmllcygpKSxcbiAgICAgICAgdXJsOiBpbnN0YW5jZS5nZXRVcmwoKVxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IGFwaVJlcXVlc3RIZWFkZXJzXG4gICAgfSkgOiBoZWxwZXJzLmZldGNoRmVhdHVyZXNDYWxsKHtcbiAgICAgIGhvc3Q6IGFwaUhvc3QsXG4gICAgICBjbGllbnRLZXksXG4gICAgICBoZWFkZXJzOiBhcGlSZXF1ZXN0SGVhZGVyc1xuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogYXV0by1yZXRyeSBpZiBzdGF0dXMgY29kZSBpbmRpY2F0ZXMgYSB0ZW1wb3JhcnkgZXJyb3JcbiAgICBwcm9taXNlID0gZmV0Y2hlci50aGVuKHJlcyA9PiB7XG4gICAgICBpZiAocmVzLmhlYWRlcnMuZ2V0KFwieC1zc2Utc3VwcG9ydFwiKSA9PT0gXCJlbmFibGVkXCIpIHtcbiAgICAgICAgc3VwcG9ydHNTU0UuYWRkKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgb25OZXdGZWF0dXJlRGF0YShrZXksIGNhY2hlS2V5LCBkYXRhKTtcbiAgICAgIHN0YXJ0QXV0b1JlZnJlc2goaW5zdGFuY2UpO1xuICAgICAgYWN0aXZlRmV0Y2hlcy5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaW5zdGFuY2UubG9nKFwiRXJyb3IgZmV0Y2hpbmcgZmVhdHVyZXNcIiwge1xuICAgICAgICBhcGlIb3N0LFxuICAgICAgICBjbGllbnRLZXksXG4gICAgICAgIGVycm9yOiBlID8gZS5tZXNzYWdlIDogbnVsbFxuICAgICAgfSk7XG4gICAgICBhY3RpdmVGZXRjaGVzLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9KTtcbiAgICBhY3RpdmVGZXRjaGVzLnNldChjYWNoZUtleSwgcHJvbWlzZSk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG59XG5cbi8vIFdhdGNoIGEgZmVhdHVyZSBlbmRwb2ludCBmb3IgY2hhbmdlc1xuLy8gV2lsbCBwcmVmZXIgU1NFIGlmIGVuYWJsZWQsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gY3JvblxuZnVuY3Rpb24gc3RhcnRBdXRvUmVmcmVzaChpbnN0YW5jZSkge1xuICBjb25zdCBrZXkgPSBnZXRLZXkoaW5zdGFuY2UpO1xuICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGluc3RhbmNlKTtcbiAgY29uc3Qge1xuICAgIHN0cmVhbWluZ0hvc3QsXG4gICAgc3RyZWFtaW5nSG9zdFJlcXVlc3RIZWFkZXJzXG4gIH0gPSBpbnN0YW5jZS5nZXRBcGlIb3N0cygpO1xuICBjb25zdCBjbGllbnRLZXkgPSBpbnN0YW5jZS5nZXRDbGllbnRLZXkoKTtcbiAgaWYgKGNhY2hlU2V0dGluZ3MuYmFja2dyb3VuZFN5bmMgJiYgc3VwcG9ydHNTU0UuaGFzKGtleSkgJiYgcG9seWZpbGxzLkV2ZW50U291cmNlKSB7XG4gICAgaWYgKHN0cmVhbXMuaGFzKGtleSkpIHJldHVybjtcbiAgICBjb25zdCBjaGFubmVsID0ge1xuICAgICAgc3JjOiBudWxsLFxuICAgICAgaG9zdDogc3RyZWFtaW5nSG9zdCxcbiAgICAgIGNsaWVudEtleSxcbiAgICAgIGhlYWRlcnM6IHN0cmVhbWluZ0hvc3RSZXF1ZXN0SGVhZGVycyxcbiAgICAgIGNiOiBldmVudCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiZmVhdHVyZXMtdXBkYXRlZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZXMgPSBzdWJzY3JpYmVkSW5zdGFuY2VzLmdldChrZXkpO1xuICAgICAgICAgICAgaW5zdGFuY2VzICYmIGluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgZmV0Y2hGZWF0dXJlcyhpbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwiZmVhdHVyZXNcIikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBvbk5ld0ZlYXR1cmVEYXRhKGtleSwgY2FjaGVLZXksIGpzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCBlcnJvciBjb3VudCBvbiBzdWNjZXNzXG4gICAgICAgICAgY2hhbm5lbC5lcnJvcnMgPSAwO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGluc3RhbmNlLmxvZyhcIlNTRSBFcnJvclwiLCB7XG4gICAgICAgICAgICBzdHJlYW1pbmdIb3N0LFxuICAgICAgICAgICAgY2xpZW50S2V5LFxuICAgICAgICAgICAgZXJyb3I6IGUgPyBlLm1lc3NhZ2UgOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb25TU0VFcnJvcihjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVycm9yczogMCxcbiAgICAgIHN0YXRlOiBcImFjdGl2ZVwiXG4gICAgfTtcbiAgICBzdHJlYW1zLnNldChrZXksIGNoYW5uZWwpO1xuICAgIGVuYWJsZUNoYW5uZWwoY2hhbm5lbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uU1NFRXJyb3IoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJpZGxlXCIpIHJldHVybjtcbiAgY2hhbm5lbC5lcnJvcnMrKztcbiAgaWYgKGNoYW5uZWwuZXJyb3JzID4gMyB8fCBjaGFubmVsLnNyYyAmJiBjaGFubmVsLnNyYy5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBhZnRlciA0IGVycm9ycywgd2l0aCBqaXR0ZXJcbiAgICBjb25zdCBkZWxheSA9IE1hdGgucG93KDMsIGNoYW5uZWwuZXJyb3JzIC0gMykgKiAoMTAwMCArIE1hdGgucmFuZG9tKCkgKiAxMDAwKTtcbiAgICBkaXNhYmxlQ2hhbm5lbChjaGFubmVsKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChbXCJpZGxlXCIsIFwiYWN0aXZlXCJdLmluY2x1ZGVzKGNoYW5uZWwuc3RhdGUpKSByZXR1cm47XG4gICAgICBlbmFibGVDaGFubmVsKGNoYW5uZWwpO1xuICAgIH0sIE1hdGgubWluKGRlbGF5LCAzMDAwMDApKTsgLy8gNSBtaW51dGVzIG1heFxuICB9XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVDaGFubmVsKGNoYW5uZWwpIHtcbiAgaWYgKCFjaGFubmVsLnNyYykgcmV0dXJuO1xuICBjaGFubmVsLnNyYy5vbm9wZW4gPSBudWxsO1xuICBjaGFubmVsLnNyYy5vbmVycm9yID0gbnVsbDtcbiAgY2hhbm5lbC5zcmMuY2xvc2UoKTtcbiAgY2hhbm5lbC5zcmMgPSBudWxsO1xuICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJhY3RpdmVcIikge1xuICAgIGNoYW5uZWwuc3RhdGUgPSBcImRpc2FibGVkXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuYWJsZUNoYW5uZWwoY2hhbm5lbCkge1xuICBjaGFubmVsLnNyYyA9IGhlbHBlcnMuZXZlbnRTb3VyY2VDYWxsKHtcbiAgICBob3N0OiBjaGFubmVsLmhvc3QsXG4gICAgY2xpZW50S2V5OiBjaGFubmVsLmNsaWVudEtleSxcbiAgICBoZWFkZXJzOiBjaGFubmVsLmhlYWRlcnNcbiAgfSk7XG4gIGNoYW5uZWwuc3RhdGUgPSBcImFjdGl2ZVwiO1xuICBjaGFubmVsLnNyYy5hZGRFdmVudExpc3RlbmVyKFwiZmVhdHVyZXNcIiwgY2hhbm5lbC5jYik7XG4gIGNoYW5uZWwuc3JjLmFkZEV2ZW50TGlzdGVuZXIoXCJmZWF0dXJlcy11cGRhdGVkXCIsIGNoYW5uZWwuY2IpO1xuICBjaGFubmVsLnNyYy5vbmVycm9yID0gKCkgPT4gb25TU0VFcnJvcihjaGFubmVsKTtcbiAgY2hhbm5lbC5zcmMub25vcGVuID0gKCkgPT4ge1xuICAgIGNoYW5uZWwuZXJyb3JzID0gMDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lDaGFubmVsKGNoYW5uZWwsIGtleSkge1xuICBkaXNhYmxlQ2hhbm5lbChjaGFubmVsKTtcbiAgc3RyZWFtcy5kZWxldGUoa2V5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQXV0b1JlZnJlc2goKSB7XG4gIC8vIENsZWFyIGxpc3Qgb2Ygd2hpY2gga2V5cyBhcmUgYXV0by11cGRhdGVkXG4gIHN1cHBvcnRzU1NFLmNsZWFyKCk7XG5cbiAgLy8gU3RvcCBsaXN0ZW5pbmcgZm9yIGFueSBTU0UgZXZlbnRzXG4gIHN0cmVhbXMuZm9yRWFjaChkZXN0cm95Q2hhbm5lbCk7XG5cbiAgLy8gUmVtb3ZlIGFsbCByZWZlcmVuY2VzIHRvIEdyb3d0aEJvb2sgaW5zdGFuY2VzXG4gIHN1YnNjcmliZWRJbnN0YW5jZXMuY2xlYXIoKTtcblxuICAvLyBSdW4gdGhlIGlkbGUgc3RyZWFtIGNsZWFudXAgZnVuY3Rpb25cbiAgaGVscGVycy5zdG9wSWRsZUxpc3RlbmVyKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWF0dXJlLXJlcG9zaXRvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/feature-repository.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/mongrule.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/mongrule.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalCondition: () => (/* binding */ evalCondition)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/util.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\nconst _regexCache = {};\n\n// The top-level condition evaluation function\nfunction evalCondition(obj, condition) {\n  // Recursive condition\n  if (\"$or\" in condition) {\n    return evalOr(obj, condition[\"$or\"]);\n  }\n  if (\"$nor\" in condition) {\n    return !evalOr(obj, condition[\"$nor\"]);\n  }\n  if (\"$and\" in condition) {\n    return evalAnd(obj, condition[\"$and\"]);\n  }\n  if (\"$not\" in condition) {\n    return !evalCondition(obj, condition[\"$not\"]);\n  }\n\n  // Condition is an object, keys are object paths, values are the condition for that path\n  for (const [k, v] of Object.entries(condition)) {\n    if (!evalConditionValue(v, getPath(obj, k))) return false;\n  }\n  return true;\n}\n\n// Return value at dot-separated path of an object\nfunction getPath(obj, path) {\n  const parts = path.split(\".\");\n  let current = obj;\n  for (let i = 0; i < parts.length; i++) {\n    if (current && typeof current === \"object\" && parts[i] in current) {\n      current = current[parts[i]];\n    } else {\n      return null;\n    }\n  }\n  return current;\n}\n\n// Transform a regex string into a real RegExp object\nfunction getRegex(regex) {\n  if (!_regexCache[regex]) {\n    _regexCache[regex] = new RegExp(regex.replace(/([^\\\\])\\//g, \"$1\\\\/\"));\n  }\n  return _regexCache[regex];\n}\n\n// Evaluate a single value against a condition\nfunction evalConditionValue(condition, value) {\n  // Simple equality comparisons\n  if (typeof condition === \"string\") {\n    return value + \"\" === condition;\n  }\n  if (typeof condition === \"number\") {\n    return value * 1 === condition;\n  }\n  if (typeof condition === \"boolean\") {\n    return !!value === condition;\n  }\n  if (condition === null) {\n    return value === null;\n  }\n  if (Array.isArray(condition) || !isOperatorObject(condition)) {\n    return JSON.stringify(value) === JSON.stringify(condition);\n  }\n\n  // This is a special operator condition and we should evaluate each one separately\n  for (const op in condition) {\n    if (!evalOperatorCondition(op, value, condition[op])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If the object has only keys that start with '$'\nfunction isOperatorObject(obj) {\n  const keys = Object.keys(obj);\n  return keys.length > 0 && keys.filter(k => k[0] === \"$\").length === keys.length;\n}\n\n// Return the data type of a value\nfunction getType(v) {\n  if (v === null) return \"null\";\n  if (Array.isArray(v)) return \"array\";\n  const t = typeof v;\n  if ([\"string\", \"number\", \"boolean\", \"object\", \"undefined\"].includes(t)) {\n    return t;\n  }\n  return \"unknown\";\n}\n\n// At least one element of actual must match the expected condition/value\nfunction elemMatch(actual, expected) {\n  if (!Array.isArray(actual)) return false;\n  const check = isOperatorObject(expected) ? v => evalConditionValue(expected, v) : v => evalCondition(v, expected);\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] && check(actual[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isIn(actual, expected) {\n  // Do an intersection is attribute is an array\n  if (Array.isArray(actual)) {\n    return actual.some(el => expected.includes(el));\n  }\n  return expected.includes(actual);\n}\n\n// Evaluate a single operator condition\nfunction evalOperatorCondition(operator, actual, expected) {\n  switch (operator) {\n    case \"$veq\":\n      return (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(actual) === (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(expected);\n    case \"$vne\":\n      return (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(actual) !== (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(expected);\n    case \"$vgt\":\n      return (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(actual) > (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(expected);\n    case \"$vgte\":\n      return (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(actual) >= (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(expected);\n    case \"$vlt\":\n      return (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(actual) < (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(expected);\n    case \"$vlte\":\n      return (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(actual) <= (0,_util__WEBPACK_IMPORTED_MODULE_0__.paddedVersionString)(expected);\n    case \"$eq\":\n      return actual === expected;\n    case \"$ne\":\n      return actual !== expected;\n    case \"$lt\":\n      return actual < expected;\n    case \"$lte\":\n      return actual <= expected;\n    case \"$gt\":\n      return actual > expected;\n    case \"$gte\":\n      return actual >= expected;\n    case \"$exists\":\n      // Using `!=` and `==` instead of strict checks so it also matches for undefined\n      return expected ? actual != null : actual == null;\n    case \"$in\":\n      if (!Array.isArray(expected)) return false;\n      return isIn(actual, expected);\n    case \"$nin\":\n      if (!Array.isArray(expected)) return false;\n      return !isIn(actual, expected);\n    case \"$not\":\n      return !evalConditionValue(expected, actual);\n    case \"$size\":\n      if (!Array.isArray(actual)) return false;\n      return evalConditionValue(expected, actual.length);\n    case \"$elemMatch\":\n      return elemMatch(actual, expected);\n    case \"$all\":\n      if (!Array.isArray(actual)) return false;\n      for (let i = 0; i < expected.length; i++) {\n        let passed = false;\n        for (let j = 0; j < actual.length; j++) {\n          if (evalConditionValue(expected[i], actual[j])) {\n            passed = true;\n            break;\n          }\n        }\n        if (!passed) return false;\n      }\n      return true;\n    case \"$regex\":\n      try {\n        return getRegex(expected).test(actual);\n      } catch (e) {\n        return false;\n      }\n    case \"$type\":\n      return getType(actual) === expected;\n    default:\n      console.error(\"Unknown operator: \" + operator);\n      return false;\n  }\n}\n\n// Recursive $or rule\nfunction evalOr(obj, conditions) {\n  if (!conditions.length) return true;\n  for (let i = 0; i < conditions.length; i++) {\n    if (evalCondition(obj, conditions[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Recursive $and rule\nfunction evalAnd(obj, conditions) {\n  for (let i = 0; i < conditions.length; i++) {\n    if (!evalCondition(obj, conditions[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n//# sourceMappingURL=mongrule.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bncm93dGhib29rK2dyb3d0aGJvb2tAMC4zMi4wL25vZGVfbW9kdWxlcy9AZ3Jvd3RoYm9vay9ncm93dGhib29rL2Rpc3QvZXNtL21vbmdydWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRTZDO0FBQzdDOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMERBQW1CLGFBQWEsMERBQW1CO0FBQ2hFO0FBQ0EsYUFBYSwwREFBbUIsYUFBYSwwREFBbUI7QUFDaEU7QUFDQSxhQUFhLDBEQUFtQixXQUFXLDBEQUFtQjtBQUM5RDtBQUNBLGFBQWEsMERBQW1CLFlBQVksMERBQW1CO0FBQy9EO0FBQ0EsYUFBYSwwREFBbUIsV0FBVywwREFBbUI7QUFDOUQ7QUFDQSxhQUFhLDBEQUFtQixZQUFZLDBEQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGdyb3d0aGJvb2srZ3Jvd3RoYm9va0AwLjMyLjAvbm9kZV9tb2R1bGVzL0Bncm93dGhib29rL2dyb3d0aGJvb2svZGlzdC9lc20vbW9uZ3J1bGUuanM/YTgyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbmltcG9ydCB7IHBhZGRlZFZlcnNpb25TdHJpbmcgfSBmcm9tIFwiLi91dGlsXCI7XG5jb25zdCBfcmVnZXhDYWNoZSA9IHt9O1xuXG4vLyBUaGUgdG9wLWxldmVsIGNvbmRpdGlvbiBldmFsdWF0aW9uIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gZXZhbENvbmRpdGlvbihvYmosIGNvbmRpdGlvbikge1xuICAvLyBSZWN1cnNpdmUgY29uZGl0aW9uXG4gIGlmIChcIiRvclwiIGluIGNvbmRpdGlvbikge1xuICAgIHJldHVybiBldmFsT3Iob2JqLCBjb25kaXRpb25bXCIkb3JcIl0pO1xuICB9XG4gIGlmIChcIiRub3JcIiBpbiBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gIWV2YWxPcihvYmosIGNvbmRpdGlvbltcIiRub3JcIl0pO1xuICB9XG4gIGlmIChcIiRhbmRcIiBpbiBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gZXZhbEFuZChvYmosIGNvbmRpdGlvbltcIiRhbmRcIl0pO1xuICB9XG4gIGlmIChcIiRub3RcIiBpbiBjb25kaXRpb24pIHtcbiAgICByZXR1cm4gIWV2YWxDb25kaXRpb24ob2JqLCBjb25kaXRpb25bXCIkbm90XCJdKTtcbiAgfVxuXG4gIC8vIENvbmRpdGlvbiBpcyBhbiBvYmplY3QsIGtleXMgYXJlIG9iamVjdCBwYXRocywgdmFsdWVzIGFyZSB0aGUgY29uZGl0aW9uIGZvciB0aGF0IHBhdGhcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoY29uZGl0aW9uKSkge1xuICAgIGlmICghZXZhbENvbmRpdGlvblZhbHVlKHYsIGdldFBhdGgob2JqLCBrKSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUmV0dXJuIHZhbHVlIGF0IGRvdC1zZXBhcmF0ZWQgcGF0aCBvZiBhbiBvYmplY3RcbmZ1bmN0aW9uIGdldFBhdGgob2JqLCBwYXRoKSB7XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIGxldCBjdXJyZW50ID0gb2JqO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnQgJiYgdHlwZW9mIGN1cnJlbnQgPT09IFwib2JqZWN0XCIgJiYgcGFydHNbaV0gaW4gY3VycmVudCkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydHNbaV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8vIFRyYW5zZm9ybSBhIHJlZ2V4IHN0cmluZyBpbnRvIGEgcmVhbCBSZWdFeHAgb2JqZWN0XG5mdW5jdGlvbiBnZXRSZWdleChyZWdleCkge1xuICBpZiAoIV9yZWdleENhY2hlW3JlZ2V4XSkge1xuICAgIF9yZWdleENhY2hlW3JlZ2V4XSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgvKFteXFxcXF0pXFwvL2csIFwiJDFcXFxcL1wiKSk7XG4gIH1cbiAgcmV0dXJuIF9yZWdleENhY2hlW3JlZ2V4XTtcbn1cblxuLy8gRXZhbHVhdGUgYSBzaW5nbGUgdmFsdWUgYWdhaW5zdCBhIGNvbmRpdGlvblxuZnVuY3Rpb24gZXZhbENvbmRpdGlvblZhbHVlKGNvbmRpdGlvbiwgdmFsdWUpIHtcbiAgLy8gU2ltcGxlIGVxdWFsaXR5IGNvbXBhcmlzb25zXG4gIGlmICh0eXBlb2YgY29uZGl0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgXCJcIiA9PT0gY29uZGl0aW9uO1xuICB9XG4gIGlmICh0eXBlb2YgY29uZGl0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlICogMSA9PT0gY29uZGl0aW9uO1xuICB9XG4gIGlmICh0eXBlb2YgY29uZGl0aW9uID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiAhIXZhbHVlID09PSBjb25kaXRpb247XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjb25kaXRpb24pIHx8ICFpc09wZXJhdG9yT2JqZWN0KGNvbmRpdGlvbikpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpID09PSBKU09OLnN0cmluZ2lmeShjb25kaXRpb24pO1xuICB9XG5cbiAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgb3BlcmF0b3IgY29uZGl0aW9uIGFuZCB3ZSBzaG91bGQgZXZhbHVhdGUgZWFjaCBvbmUgc2VwYXJhdGVseVxuICBmb3IgKGNvbnN0IG9wIGluIGNvbmRpdGlvbikge1xuICAgIGlmICghZXZhbE9wZXJhdG9yQ29uZGl0aW9uKG9wLCB2YWx1ZSwgY29uZGl0aW9uW29wXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIElmIHRoZSBvYmplY3QgaGFzIG9ubHkga2V5cyB0aGF0IHN0YXJ0IHdpdGggJyQnXG5mdW5jdGlvbiBpc09wZXJhdG9yT2JqZWN0KG9iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgcmV0dXJuIGtleXMubGVuZ3RoID4gMCAmJiBrZXlzLmZpbHRlcihrID0+IGtbMF0gPT09IFwiJFwiKS5sZW5ndGggPT09IGtleXMubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm4gdGhlIGRhdGEgdHlwZSBvZiBhIHZhbHVlXG5mdW5jdGlvbiBnZXRUeXBlKHYpIHtcbiAgaWYgKHYgPT09IG51bGwpIHJldHVybiBcIm51bGxcIjtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiBcImFycmF5XCI7XG4gIGNvbnN0IHQgPSB0eXBlb2YgdjtcbiAgaWYgKFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIiwgXCJvYmplY3RcIiwgXCJ1bmRlZmluZWRcIl0uaW5jbHVkZXModCkpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5cbi8vIEF0IGxlYXN0IG9uZSBlbGVtZW50IG9mIGFjdHVhbCBtdXN0IG1hdGNoIHRoZSBleHBlY3RlZCBjb25kaXRpb24vdmFsdWVcbmZ1bmN0aW9uIGVsZW1NYXRjaChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhY3R1YWwpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNoZWNrID0gaXNPcGVyYXRvck9iamVjdChleHBlY3RlZCkgPyB2ID0+IGV2YWxDb25kaXRpb25WYWx1ZShleHBlY3RlZCwgdikgOiB2ID0+IGV2YWxDb25kaXRpb24odiwgZXhwZWN0ZWQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhY3R1YWxbaV0gJiYgY2hlY2soYWN0dWFsW2ldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSW4oYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyBEbyBhbiBpbnRlcnNlY3Rpb24gaXMgYXR0cmlidXRlIGlzIGFuIGFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KGFjdHVhbCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvbWUoZWwgPT4gZXhwZWN0ZWQuaW5jbHVkZXMoZWwpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0ZWQuaW5jbHVkZXMoYWN0dWFsKTtcbn1cblxuLy8gRXZhbHVhdGUgYSBzaW5nbGUgb3BlcmF0b3IgY29uZGl0aW9uXG5mdW5jdGlvbiBldmFsT3BlcmF0b3JDb25kaXRpb24ob3BlcmF0b3IsIGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgXCIkdmVxXCI6XG4gICAgICByZXR1cm4gcGFkZGVkVmVyc2lvblN0cmluZyhhY3R1YWwpID09PSBwYWRkZWRWZXJzaW9uU3RyaW5nKGV4cGVjdGVkKTtcbiAgICBjYXNlIFwiJHZuZVwiOlxuICAgICAgcmV0dXJuIHBhZGRlZFZlcnNpb25TdHJpbmcoYWN0dWFsKSAhPT0gcGFkZGVkVmVyc2lvblN0cmluZyhleHBlY3RlZCk7XG4gICAgY2FzZSBcIiR2Z3RcIjpcbiAgICAgIHJldHVybiBwYWRkZWRWZXJzaW9uU3RyaW5nKGFjdHVhbCkgPiBwYWRkZWRWZXJzaW9uU3RyaW5nKGV4cGVjdGVkKTtcbiAgICBjYXNlIFwiJHZndGVcIjpcbiAgICAgIHJldHVybiBwYWRkZWRWZXJzaW9uU3RyaW5nKGFjdHVhbCkgPj0gcGFkZGVkVmVyc2lvblN0cmluZyhleHBlY3RlZCk7XG4gICAgY2FzZSBcIiR2bHRcIjpcbiAgICAgIHJldHVybiBwYWRkZWRWZXJzaW9uU3RyaW5nKGFjdHVhbCkgPCBwYWRkZWRWZXJzaW9uU3RyaW5nKGV4cGVjdGVkKTtcbiAgICBjYXNlIFwiJHZsdGVcIjpcbiAgICAgIHJldHVybiBwYWRkZWRWZXJzaW9uU3RyaW5nKGFjdHVhbCkgPD0gcGFkZGVkVmVyc2lvblN0cmluZyhleHBlY3RlZCk7XG4gICAgY2FzZSBcIiRlcVwiOlxuICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG4gICAgY2FzZSBcIiRuZVwiOlxuICAgICAgcmV0dXJuIGFjdHVhbCAhPT0gZXhwZWN0ZWQ7XG4gICAgY2FzZSBcIiRsdFwiOlxuICAgICAgcmV0dXJuIGFjdHVhbCA8IGV4cGVjdGVkO1xuICAgIGNhc2UgXCIkbHRlXCI6XG4gICAgICByZXR1cm4gYWN0dWFsIDw9IGV4cGVjdGVkO1xuICAgIGNhc2UgXCIkZ3RcIjpcbiAgICAgIHJldHVybiBhY3R1YWwgPiBleHBlY3RlZDtcbiAgICBjYXNlIFwiJGd0ZVwiOlxuICAgICAgcmV0dXJuIGFjdHVhbCA+PSBleHBlY3RlZDtcbiAgICBjYXNlIFwiJGV4aXN0c1wiOlxuICAgICAgLy8gVXNpbmcgYCE9YCBhbmQgYD09YCBpbnN0ZWFkIG9mIHN0cmljdCBjaGVja3Mgc28gaXQgYWxzbyBtYXRjaGVzIGZvciB1bmRlZmluZWRcbiAgICAgIHJldHVybiBleHBlY3RlZCA/IGFjdHVhbCAhPSBudWxsIDogYWN0dWFsID09IG51bGw7XG4gICAgY2FzZSBcIiRpblwiOlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIGlzSW4oYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgY2FzZSBcIiRuaW5cIjpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiAhaXNJbihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICBjYXNlIFwiJG5vdFwiOlxuICAgICAgcmV0dXJuICFldmFsQ29uZGl0aW9uVmFsdWUoZXhwZWN0ZWQsIGFjdHVhbCk7XG4gICAgY2FzZSBcIiRzaXplXCI6XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWN0dWFsKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIGV2YWxDb25kaXRpb25WYWx1ZShleHBlY3RlZCwgYWN0dWFsLmxlbmd0aCk7XG4gICAgY2FzZSBcIiRlbGVtTWF0Y2hcIjpcbiAgICAgIHJldHVybiBlbGVtTWF0Y2goYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgY2FzZSBcIiRhbGxcIjpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhY3R1YWwpKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwYXNzZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhY3R1YWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoZXZhbENvbmRpdGlvblZhbHVlKGV4cGVjdGVkW2ldLCBhY3R1YWxbal0pKSB7XG4gICAgICAgICAgICBwYXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFzc2VkKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiJHJlZ2V4XCI6XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZ2V0UmVnZXgoZXhwZWN0ZWQpLnRlc3QoYWN0dWFsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGNhc2UgXCIkdHlwZVwiOlxuICAgICAgcmV0dXJuIGdldFR5cGUoYWN0dWFsKSA9PT0gZXhwZWN0ZWQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIG9wZXJhdG9yOiBcIiArIG9wZXJhdG9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBSZWN1cnNpdmUgJG9yIHJ1bGVcbmZ1bmN0aW9uIGV2YWxPcihvYmosIGNvbmRpdGlvbnMpIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChldmFsQ29uZGl0aW9uKG9iaiwgY29uZGl0aW9uc1tpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFJlY3Vyc2l2ZSAkYW5kIHJ1bGVcbmZ1bmN0aW9uIGV2YWxBbmQob2JqLCBjb25kaXRpb25zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZXZhbENvbmRpdGlvbihvYmosIGNvbmRpdGlvbnNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9uZ3J1bGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/mongrule.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/util.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/util.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chooseVariation: () => (/* binding */ chooseVariation),\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   getBucketRanges: () => (/* binding */ getBucketRanges),\n/* harmony export */   getEqualWeights: () => (/* binding */ getEqualWeights),\n/* harmony export */   getQueryStringOverride: () => (/* binding */ getQueryStringOverride),\n/* harmony export */   getUrlRegExp: () => (/* binding */ getUrlRegExp),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   inNamespace: () => (/* binding */ inNamespace),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isIncluded: () => (/* binding */ isIncluded),\n/* harmony export */   isURLTargeted: () => (/* binding */ isURLTargeted),\n/* harmony export */   loadSDKVersion: () => (/* binding */ loadSDKVersion),\n/* harmony export */   paddedVersionString: () => (/* binding */ paddedVersionString),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\nfunction hashFnv32a(str) {\n  let hval = 0x811c9dc5;\n  const l = str.length;\n  for (let i = 0; i < l; i++) {\n    hval ^= str.charCodeAt(i);\n    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);\n  }\n  return hval >>> 0;\n}\nfunction hash(seed, value, version) {\n  // New unbiased hashing algorithm\n  if (version === 2) {\n    return hashFnv32a(hashFnv32a(seed + value) + \"\") % 10000 / 10000;\n  }\n  // Original biased hashing algorithm (keep for backwards compatibility)\n  if (version === 1) {\n    return hashFnv32a(value + seed) % 1000 / 1000;\n  }\n\n  // Unknown hash version\n  return null;\n}\nfunction getEqualWeights(n) {\n  if (n <= 0) return [];\n  return new Array(n).fill(1 / n);\n}\nfunction inRange(n, range) {\n  return n >= range[0] && n < range[1];\n}\nfunction inNamespace(hashValue, namespace) {\n  const n = hash(\"__\" + namespace[0], hashValue, 1);\n  if (n === null) return false;\n  return n >= namespace[1] && n < namespace[2];\n}\nfunction chooseVariation(n, ranges) {\n  for (let i = 0; i < ranges.length; i++) {\n    if (inRange(n, ranges[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction getUrlRegExp(regexString) {\n  try {\n    const escaped = regexString.replace(/([^\\\\])\\//g, \"$1\\\\/\");\n    return new RegExp(escaped);\n  } catch (e) {\n    console.error(e);\n    return undefined;\n  }\n}\nfunction isURLTargeted(url, targets) {\n  if (!targets.length) return false;\n  let hasIncludeRules = false;\n  let isIncluded = false;\n  for (let i = 0; i < targets.length; i++) {\n    const match = _evalURLTarget(url, targets[i].type, targets[i].pattern);\n    if (targets[i].include === false) {\n      if (match) return false;\n    } else {\n      hasIncludeRules = true;\n      if (match) isIncluded = true;\n    }\n  }\n  return isIncluded || !hasIncludeRules;\n}\nfunction _evalSimpleUrlPart(actual, pattern, isPath) {\n  try {\n    // Escape special regex characters and change wildcard `_____` to `.*`\n    let escaped = pattern.replace(/[*.+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/_____/g, \".*\");\n    if (isPath) {\n      // When matching pathname, make leading/trailing slashes optional\n      escaped = \"\\\\/?\" + escaped.replace(/(^\\/|\\/$)/g, \"\") + \"\\\\/?\";\n    }\n    const regex = new RegExp(\"^\" + escaped + \"$\", \"i\");\n    return regex.test(actual);\n  } catch (e) {\n    return false;\n  }\n}\nfunction _evalSimpleUrlTarget(actual, pattern) {\n  try {\n    // If a protocol is missing, but a host is specified, add `https://` to the front\n    // Use \"_____\" as the wildcard since `*` is not a valid hostname in some browsers\n    const expected = new URL(pattern.replace(/^([^:/?]*)\\./i, \"https://$1.\").replace(/\\*/g, \"_____\"), \"https://_____\");\n\n    // Compare each part of the URL separately\n    const comps = [[actual.host, expected.host, false], [actual.pathname, expected.pathname, true]];\n    // We only want to compare hashes if it's explicitly being targeted\n    if (expected.hash) {\n      comps.push([actual.hash, expected.hash, false]);\n    }\n    expected.searchParams.forEach((v, k) => {\n      comps.push([actual.searchParams.get(k) || \"\", v, false]);\n    });\n\n    // If any comparisons fail, the whole thing fails\n    return !comps.some(data => !_evalSimpleUrlPart(data[0], data[1], data[2]));\n  } catch (e) {\n    return false;\n  }\n}\nfunction _evalURLTarget(url, type, pattern) {\n  try {\n    const parsed = new URL(url, \"https://_\");\n    if (type === \"regex\") {\n      const regex = getUrlRegExp(pattern);\n      if (!regex) return false;\n      return regex.test(parsed.href) || regex.test(parsed.href.substring(parsed.origin.length));\n    } else if (type === \"simple\") {\n      return _evalSimpleUrlTarget(parsed, pattern);\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction getBucketRanges(numVariations, coverage, weights) {\n  coverage = coverage === undefined ? 1 : coverage;\n\n  // Make sure coverage is within bounds\n  if (coverage < 0) {\n    if (true) {\n      console.error(\"Experiment.coverage must be greater than or equal to 0\");\n    }\n    coverage = 0;\n  } else if (coverage > 1) {\n    if (true) {\n      console.error(\"Experiment.coverage must be less than or equal to 1\");\n    }\n    coverage = 1;\n  }\n\n  // Default to equal weights if missing or invalid\n  const equal = getEqualWeights(numVariations);\n  weights = weights || equal;\n  if (weights.length !== numVariations) {\n    if (true) {\n      console.error(\"Experiment.weights array must be the same length as Experiment.variations\");\n    }\n    weights = equal;\n  }\n\n  // If weights don't add up to 1 (or close to it), default to equal weights\n  const totalWeight = weights.reduce((w, sum) => sum + w, 0);\n  if (totalWeight < 0.99 || totalWeight > 1.01) {\n    if (true) {\n      console.error(\"Experiment.weights must add up to 1\");\n    }\n    weights = equal;\n  }\n\n  // Covert weights to ranges\n  let cumulative = 0;\n  return weights.map(w => {\n    const start = cumulative;\n    cumulative += w;\n    return [start, start + coverage * w];\n  });\n}\nfunction getQueryStringOverride(id, url, numVariations) {\n  if (!url) {\n    return null;\n  }\n  const search = url.split(\"?\")[1];\n  if (!search) {\n    return null;\n  }\n  const match = search.replace(/#.*/, \"\") // Get rid of anchor\n  .split(\"&\") // Split into key/value pairs\n  .map(kv => kv.split(\"=\", 2)).filter(_ref => {\n    let [k] = _ref;\n    return k === id;\n  }) // Look for key that matches the experiment id\n  .map(_ref2 => {\n    let [, v] = _ref2;\n    return parseInt(v);\n  }); // Parse the value into an integer\n\n  if (match.length > 0 && match[0] >= 0 && match[0] < numVariations) return match[0];\n  return null;\n}\nfunction isIncluded(include) {\n  try {\n    return include();\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\nconst base64ToBuf = b => Uint8Array.from(atob(b), c => c.charCodeAt(0));\nasync function decrypt(encryptedString, decryptionKey, subtle) {\n  decryptionKey = decryptionKey || \"\";\n  subtle = subtle || globalThis.crypto && globalThis.crypto.subtle;\n  if (!subtle) {\n    throw new Error(\"No SubtleCrypto implementation found\");\n  }\n  try {\n    const key = await subtle.importKey(\"raw\", base64ToBuf(decryptionKey), {\n      name: \"AES-CBC\",\n      length: 128\n    }, true, [\"encrypt\", \"decrypt\"]);\n    const [iv, cipherText] = encryptedString.split(\".\");\n    const plainTextBuffer = await subtle.decrypt({\n      name: \"AES-CBC\",\n      iv: base64ToBuf(iv)\n    }, key, base64ToBuf(cipherText));\n    return new TextDecoder().decode(plainTextBuffer);\n  } catch (e) {\n    throw new Error(\"Failed to decrypt\");\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction toString(input) {\n  if (typeof input === \"string\") return input;\n  return JSON.stringify(input);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction paddedVersionString(input) {\n  if (typeof input === \"number\") {\n    input = input + \"\";\n  }\n  if (!input || typeof input !== \"string\") {\n    input = \"0\";\n  }\n  // Remove build info and leading `v` if any\n  // Split version into parts (both core version numbers and pre-release tags)\n  // \"v1.2.3-rc.1+build123\" -> [\"1\",\"2\",\"3\",\"rc\",\"1\"]\n  const parts = input.replace(/(^v|\\+.*$)/g, \"\").split(/[-.]/);\n\n  // If it's SemVer without a pre-release, add `~` to the end\n  // [\"1\",\"0\",\"0\"] -> [\"1\",\"0\",\"0\",\"~\"]\n  // \"~\" is the largest ASCII character, so this will make \"1.0.0\" greater than \"1.0.0-beta\" for example\n  if (parts.length === 3) {\n    parts.push(\"~\");\n  }\n\n  // Left pad each numeric part with spaces so string comparisons will work (\"9\">\"10\", but \" 9\"<\"10\")\n  // Then, join back together into a single string\n  return parts.map(v => v.match(/^[0-9]+$/) ? v.padStart(5, \" \") : v).join(\"-\");\n}\nfunction loadSDKVersion() {\n  let version;\n  try {\n    // @ts-expect-error right-hand value to be replaced by build with string literal\n    version = \"0.32.0\";\n  } catch (e) {\n    version = \"\";\n  }\n  return version;\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bncm93dGhib29rK2dyb3d0aGJvb2tAMC4zMi4wL25vZGVfbW9kdWxlcy9AZ3Jvd3RoYm9vay9ncm93dGhib29rL2Rpc3QvZXNtL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGdyb3d0aGJvb2srZ3Jvd3RoYm9va0AwLjMyLjAvbm9kZV9tb2R1bGVzL0Bncm93dGhib29rL2dyb3d0aGJvb2svZGlzdC9lc20vdXRpbC5qcz9hY2ZlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGhhc2hGbnYzMmEoc3RyKSB7XG4gIGxldCBodmFsID0gMHg4MTFjOWRjNTtcbiAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgaHZhbCBePSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBodmFsICs9IChodmFsIDw8IDEpICsgKGh2YWwgPDwgNCkgKyAoaHZhbCA8PCA3KSArIChodmFsIDw8IDgpICsgKGh2YWwgPDwgMjQpO1xuICB9XG4gIHJldHVybiBodmFsID4+PiAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc2goc2VlZCwgdmFsdWUsIHZlcnNpb24pIHtcbiAgLy8gTmV3IHVuYmlhc2VkIGhhc2hpbmcgYWxnb3JpdGhtXG4gIGlmICh2ZXJzaW9uID09PSAyKSB7XG4gICAgcmV0dXJuIGhhc2hGbnYzMmEoaGFzaEZudjMyYShzZWVkICsgdmFsdWUpICsgXCJcIikgJSAxMDAwMCAvIDEwMDAwO1xuICB9XG4gIC8vIE9yaWdpbmFsIGJpYXNlZCBoYXNoaW5nIGFsZ29yaXRobSAoa2VlcCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc2hGbnYzMmEodmFsdWUgKyBzZWVkKSAlIDEwMDAgLyAxMDAwO1xuICB9XG5cbiAgLy8gVW5rbm93biBoYXNoIHZlcnNpb25cbiAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXF1YWxXZWlnaHRzKG4pIHtcbiAgaWYgKG4gPD0gMCkgcmV0dXJuIFtdO1xuICByZXR1cm4gbmV3IEFycmF5KG4pLmZpbGwoMSAvIG4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluUmFuZ2UobiwgcmFuZ2UpIHtcbiAgcmV0dXJuIG4gPj0gcmFuZ2VbMF0gJiYgbiA8IHJhbmdlWzFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluTmFtZXNwYWNlKGhhc2hWYWx1ZSwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IG4gPSBoYXNoKFwiX19cIiArIG5hbWVzcGFjZVswXSwgaGFzaFZhbHVlLCAxKTtcbiAgaWYgKG4gPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG4gPj0gbmFtZXNwYWNlWzFdICYmIG4gPCBuYW1lc3BhY2VbMl07XG59XG5leHBvcnQgZnVuY3Rpb24gY2hvb3NlVmFyaWF0aW9uKG4sIHJhbmdlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpblJhbmdlKG4sIHJhbmdlc1tpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsUmVnRXhwKHJlZ2V4U3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZXNjYXBlZCA9IHJlZ2V4U3RyaW5nLnJlcGxhY2UoLyhbXlxcXFxdKVxcLy9nLCBcIiQxXFxcXC9cIik7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZXNjYXBlZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1VSTFRhcmdldGVkKHVybCwgdGFyZ2V0cykge1xuICBpZiAoIXRhcmdldHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBoYXNJbmNsdWRlUnVsZXMgPSBmYWxzZTtcbiAgbGV0IGlzSW5jbHVkZWQgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBfZXZhbFVSTFRhcmdldCh1cmwsIHRhcmdldHNbaV0udHlwZSwgdGFyZ2V0c1tpXS5wYXR0ZXJuKTtcbiAgICBpZiAodGFyZ2V0c1tpXS5pbmNsdWRlID09PSBmYWxzZSkge1xuICAgICAgaWYgKG1hdGNoKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0luY2x1ZGVSdWxlcyA9IHRydWU7XG4gICAgICBpZiAobWF0Y2gpIGlzSW5jbHVkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNJbmNsdWRlZCB8fCAhaGFzSW5jbHVkZVJ1bGVzO1xufVxuZnVuY3Rpb24gX2V2YWxTaW1wbGVVcmxQYXJ0KGFjdHVhbCwgcGF0dGVybiwgaXNQYXRoKSB7XG4gIHRyeSB7XG4gICAgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcmFjdGVycyBhbmQgY2hhbmdlIHdpbGRjYXJkIGBfX19fX2AgdG8gYC4qYFxuICAgIGxldCBlc2NhcGVkID0gcGF0dGVybi5yZXBsYWNlKC9bKi4rP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIikucmVwbGFjZSgvX19fX18vZywgXCIuKlwiKTtcbiAgICBpZiAoaXNQYXRoKSB7XG4gICAgICAvLyBXaGVuIG1hdGNoaW5nIHBhdGhuYW1lLCBtYWtlIGxlYWRpbmcvdHJhaWxpbmcgc2xhc2hlcyBvcHRpb25hbFxuICAgICAgZXNjYXBlZCA9IFwiXFxcXC8/XCIgKyBlc2NhcGVkLnJlcGxhY2UoLyheXFwvfFxcLyQpL2csIFwiXCIpICsgXCJcXFxcLz9cIjtcbiAgICB9XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsgZXNjYXBlZCArIFwiJFwiLCBcImlcIik7XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QoYWN0dWFsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2V2YWxTaW1wbGVVcmxUYXJnZXQoYWN0dWFsLCBwYXR0ZXJuKSB7XG4gIHRyeSB7XG4gICAgLy8gSWYgYSBwcm90b2NvbCBpcyBtaXNzaW5nLCBidXQgYSBob3N0IGlzIHNwZWNpZmllZCwgYWRkIGBodHRwczovL2AgdG8gdGhlIGZyb250XG4gICAgLy8gVXNlIFwiX19fX19cIiBhcyB0aGUgd2lsZGNhcmQgc2luY2UgYCpgIGlzIG5vdCBhIHZhbGlkIGhvc3RuYW1lIGluIHNvbWUgYnJvd3NlcnNcbiAgICBjb25zdCBleHBlY3RlZCA9IG5ldyBVUkwocGF0dGVybi5yZXBsYWNlKC9eKFteOi8/XSopXFwuL2ksIFwiaHR0cHM6Ly8kMS5cIikucmVwbGFjZSgvXFwqL2csIFwiX19fX19cIiksIFwiaHR0cHM6Ly9fX19fX1wiKTtcblxuICAgIC8vIENvbXBhcmUgZWFjaCBwYXJ0IG9mIHRoZSBVUkwgc2VwYXJhdGVseVxuICAgIGNvbnN0IGNvbXBzID0gW1thY3R1YWwuaG9zdCwgZXhwZWN0ZWQuaG9zdCwgZmFsc2VdLCBbYWN0dWFsLnBhdGhuYW1lLCBleHBlY3RlZC5wYXRobmFtZSwgdHJ1ZV1dO1xuICAgIC8vIFdlIG9ubHkgd2FudCB0byBjb21wYXJlIGhhc2hlcyBpZiBpdCdzIGV4cGxpY2l0bHkgYmVpbmcgdGFyZ2V0ZWRcbiAgICBpZiAoZXhwZWN0ZWQuaGFzaCkge1xuICAgICAgY29tcHMucHVzaChbYWN0dWFsLmhhc2gsIGV4cGVjdGVkLmhhc2gsIGZhbHNlXSk7XG4gICAgfVxuICAgIGV4cGVjdGVkLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgICBjb21wcy5wdXNoKFthY3R1YWwuc2VhcmNoUGFyYW1zLmdldChrKSB8fCBcIlwiLCB2LCBmYWxzZV0pO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgYW55IGNvbXBhcmlzb25zIGZhaWwsIHRoZSB3aG9sZSB0aGluZyBmYWlsc1xuICAgIHJldHVybiAhY29tcHMuc29tZShkYXRhID0+ICFfZXZhbFNpbXBsZVVybFBhcnQoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBfZXZhbFVSTFRhcmdldCh1cmwsIHR5cGUsIHBhdHRlcm4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHVybCwgXCJodHRwczovL19cIik7XG4gICAgaWYgKHR5cGUgPT09IFwicmVnZXhcIikge1xuICAgICAgY29uc3QgcmVnZXggPSBnZXRVcmxSZWdFeHAocGF0dGVybik7XG4gICAgICBpZiAoIXJlZ2V4KSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gcmVnZXgudGVzdChwYXJzZWQuaHJlZikgfHwgcmVnZXgudGVzdChwYXJzZWQuaHJlZi5zdWJzdHJpbmcocGFyc2VkLm9yaWdpbi5sZW5ndGgpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic2ltcGxlXCIpIHtcbiAgICAgIHJldHVybiBfZXZhbFNpbXBsZVVybFRhcmdldChwYXJzZWQsIHBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWNrZXRSYW5nZXMobnVtVmFyaWF0aW9ucywgY292ZXJhZ2UsIHdlaWdodHMpIHtcbiAgY292ZXJhZ2UgPSBjb3ZlcmFnZSA9PT0gdW5kZWZpbmVkID8gMSA6IGNvdmVyYWdlO1xuXG4gIC8vIE1ha2Ugc3VyZSBjb3ZlcmFnZSBpcyB3aXRoaW4gYm91bmRzXG4gIGlmIChjb3ZlcmFnZSA8IDApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXhwZXJpbWVudC5jb3ZlcmFnZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICAgIH1cbiAgICBjb3ZlcmFnZSA9IDA7XG4gIH0gZWxzZSBpZiAoY292ZXJhZ2UgPiAxKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkV4cGVyaW1lbnQuY292ZXJhZ2UgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtcbiAgICB9XG4gICAgY292ZXJhZ2UgPSAxO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBlcXVhbCB3ZWlnaHRzIGlmIG1pc3Npbmcgb3IgaW52YWxpZFxuICBjb25zdCBlcXVhbCA9IGdldEVxdWFsV2VpZ2h0cyhudW1WYXJpYXRpb25zKTtcbiAgd2VpZ2h0cyA9IHdlaWdodHMgfHwgZXF1YWw7XG4gIGlmICh3ZWlnaHRzLmxlbmd0aCAhPT0gbnVtVmFyaWF0aW9ucykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFeHBlcmltZW50LndlaWdodHMgYXJyYXkgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGggYXMgRXhwZXJpbWVudC52YXJpYXRpb25zXCIpO1xuICAgIH1cbiAgICB3ZWlnaHRzID0gZXF1YWw7XG4gIH1cblxuICAvLyBJZiB3ZWlnaHRzIGRvbid0IGFkZCB1cCB0byAxIChvciBjbG9zZSB0byBpdCksIGRlZmF1bHQgdG8gZXF1YWwgd2VpZ2h0c1xuICBjb25zdCB0b3RhbFdlaWdodCA9IHdlaWdodHMucmVkdWNlKCh3LCBzdW0pID0+IHN1bSArIHcsIDApO1xuICBpZiAodG90YWxXZWlnaHQgPCAwLjk5IHx8IHRvdGFsV2VpZ2h0ID4gMS4wMSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFeHBlcmltZW50LndlaWdodHMgbXVzdCBhZGQgdXAgdG8gMVwiKTtcbiAgICB9XG4gICAgd2VpZ2h0cyA9IGVxdWFsO1xuICB9XG5cbiAgLy8gQ292ZXJ0IHdlaWdodHMgdG8gcmFuZ2VzXG4gIGxldCBjdW11bGF0aXZlID0gMDtcbiAgcmV0dXJuIHdlaWdodHMubWFwKHcgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gY3VtdWxhdGl2ZTtcbiAgICBjdW11bGF0aXZlICs9IHc7XG4gICAgcmV0dXJuIFtzdGFydCwgc3RhcnQgKyBjb3ZlcmFnZSAqIHddO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeVN0cmluZ092ZXJyaWRlKGlkLCB1cmwsIG51bVZhcmlhdGlvbnMpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzZWFyY2ggPSB1cmwuc3BsaXQoXCI/XCIpWzFdO1xuICBpZiAoIXNlYXJjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gc2VhcmNoLnJlcGxhY2UoLyMuKi8sIFwiXCIpIC8vIEdldCByaWQgb2YgYW5jaG9yXG4gIC5zcGxpdChcIiZcIikgLy8gU3BsaXQgaW50byBrZXkvdmFsdWUgcGFpcnNcbiAgLm1hcChrdiA9PiBrdi5zcGxpdChcIj1cIiwgMikpLmZpbHRlcihfcmVmID0+IHtcbiAgICBsZXQgW2tdID0gX3JlZjtcbiAgICByZXR1cm4gayA9PT0gaWQ7XG4gIH0pIC8vIExvb2sgZm9yIGtleSB0aGF0IG1hdGNoZXMgdGhlIGV4cGVyaW1lbnQgaWRcbiAgLm1hcChfcmVmMiA9PiB7XG4gICAgbGV0IFssIHZdID0gX3JlZjI7XG4gICAgcmV0dXJuIHBhcnNlSW50KHYpO1xuICB9KTsgLy8gUGFyc2UgdGhlIHZhbHVlIGludG8gYW4gaW50ZWdlclxuXG4gIGlmIChtYXRjaC5sZW5ndGggPiAwICYmIG1hdGNoWzBdID49IDAgJiYgbWF0Y2hbMF0gPCBudW1WYXJpYXRpb25zKSByZXR1cm4gbWF0Y2hbMF07XG4gIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5jbHVkZWQoaW5jbHVkZSkge1xuICB0cnkge1xuICAgIHJldHVybiBpbmNsdWRlKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY29uc3QgYmFzZTY0VG9CdWYgPSBiID0+IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGIpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChlbmNyeXB0ZWRTdHJpbmcsIGRlY3J5cHRpb25LZXksIHN1YnRsZSkge1xuICBkZWNyeXB0aW9uS2V5ID0gZGVjcnlwdGlvbktleSB8fCBcIlwiO1xuICBzdWJ0bGUgPSBzdWJ0bGUgfHwgZ2xvYmFsVGhpcy5jcnlwdG8gJiYgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlO1xuICBpZiAoIXN1YnRsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFN1YnRsZUNyeXB0byBpbXBsZW1lbnRhdGlvbiBmb3VuZFwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgYmFzZTY0VG9CdWYoZGVjcnlwdGlvbktleSksIHtcbiAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiLFxuICAgICAgbGVuZ3RoOiAxMjhcbiAgICB9LCB0cnVlLCBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSk7XG4gICAgY29uc3QgW2l2LCBjaXBoZXJUZXh0XSA9IGVuY3J5cHRlZFN0cmluZy5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgcGxhaW5UZXh0QnVmZmVyID0gYXdhaXQgc3VidGxlLmRlY3J5cHQoe1xuICAgICAgbmFtZTogXCJBRVMtQ0JDXCIsXG4gICAgICBpdjogYmFzZTY0VG9CdWYoaXYpXG4gICAgfSwga2V5LCBiYXNlNjRUb0J1ZihjaXBoZXJUZXh0KSk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShwbGFpblRleHRCdWZmZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHRcIik7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSByZXR1cm4gaW5wdXQ7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gcGFkZGVkVmVyc2lvblN0cmluZyhpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiKSB7XG4gICAgaW5wdXQgPSBpbnB1dCArIFwiXCI7XG4gIH1cbiAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpbnB1dCA9IFwiMFwiO1xuICB9XG4gIC8vIFJlbW92ZSBidWlsZCBpbmZvIGFuZCBsZWFkaW5nIGB2YCBpZiBhbnlcbiAgLy8gU3BsaXQgdmVyc2lvbiBpbnRvIHBhcnRzIChib3RoIGNvcmUgdmVyc2lvbiBudW1iZXJzIGFuZCBwcmUtcmVsZWFzZSB0YWdzKVxuICAvLyBcInYxLjIuMy1yYy4xK2J1aWxkMTIzXCIgLT4gW1wiMVwiLFwiMlwiLFwiM1wiLFwicmNcIixcIjFcIl1cbiAgY29uc3QgcGFydHMgPSBpbnB1dC5yZXBsYWNlKC8oXnZ8XFwrLiokKS9nLCBcIlwiKS5zcGxpdCgvWy0uXS8pO1xuXG4gIC8vIElmIGl0J3MgU2VtVmVyIHdpdGhvdXQgYSBwcmUtcmVsZWFzZSwgYWRkIGB+YCB0byB0aGUgZW5kXG4gIC8vIFtcIjFcIixcIjBcIixcIjBcIl0gLT4gW1wiMVwiLFwiMFwiLFwiMFwiLFwiflwiXVxuICAvLyBcIn5cIiBpcyB0aGUgbGFyZ2VzdCBBU0NJSSBjaGFyYWN0ZXIsIHNvIHRoaXMgd2lsbCBtYWtlIFwiMS4wLjBcIiBncmVhdGVyIHRoYW4gXCIxLjAuMC1iZXRhXCIgZm9yIGV4YW1wbGVcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHBhcnRzLnB1c2goXCJ+XCIpO1xuICB9XG5cbiAgLy8gTGVmdCBwYWQgZWFjaCBudW1lcmljIHBhcnQgd2l0aCBzcGFjZXMgc28gc3RyaW5nIGNvbXBhcmlzb25zIHdpbGwgd29yayAoXCI5XCI+XCIxMFwiLCBidXQgXCIgOVwiPFwiMTBcIilcbiAgLy8gVGhlbiwgam9pbiBiYWNrIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgc3RyaW5nXG4gIHJldHVybiBwYXJ0cy5tYXAodiA9PiB2Lm1hdGNoKC9eWzAtOV0rJC8pID8gdi5wYWRTdGFydCg1LCBcIiBcIikgOiB2KS5qb2luKFwiLVwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2FkU0RLVmVyc2lvbigpIHtcbiAgbGV0IHZlcnNpb247XG4gIHRyeSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByaWdodC1oYW5kIHZhbHVlIHRvIGJlIHJlcGxhY2VkIGJ5IGJ1aWxkIHdpdGggc3RyaW5nIGxpdGVyYWxcbiAgICB2ZXJzaW9uID0gXCIwLjMyLjBcIjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZlcnNpb24gPSBcIlwiO1xuICB9XG4gIHJldHVybiB2ZXJzaW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@growthbook+growthbook@0.32.0/node_modules/@growthbook/growthbook/dist/esm/util.js\n");

/***/ })

};
;